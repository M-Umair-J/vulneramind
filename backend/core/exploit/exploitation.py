# import subprocess
# import logging
# import json
# import requests
# import re
# from pathlib import Path
# # from scanner.__init__ import return_cve_results

# def search_by_product_version(product, version):
#     search = f"{product} {version}".strip()
#     try:
#         # -j for JSON output
#         output = subprocess.check_output(["searchsploit", search, "-j"], text=True)
#         data = json.loads(output)
#         return data.get("RESULTS_EXPLOIT", [])
#     except subprocess.CalledProcessError as e:
#         logging.error(f"[!] searchsploit failed: {e}")
#         return []
#     except Exception as e:
#         logging.error(f"[!] Unexpected error: {e}")
#         return []
    


# def search_by_cve(cve_id):
#     try:
#         output = subprocess.check_output(["searchsploit", cve_id, "-j"], text=True)
#         data = json.loads(output)
#         return data.get("RESULTS_EXPLOIT", [])
#     except subprocess.CalledProcessError as e:
#         logging.error(f"[!] searchsploit failed: {e}")
#         return []
#     except Exception as e:
#         logging.error(f"[!] Unexpected error: {e}")
#         return []


# def exploit_services(cve_results):
#     for service in cve_results:
#         port = service.get('port')
#         service_name = service.get('service', '')
#         product = service.get('product', '')
#         version = service.get('version', '')
#         cve_list = service.get('cves', [])

        
#         exploits_pv = search_by_product_version(product, version)

#         exploits_cve = []
#         for cve in cve_list:
#             exploits_cve.extend(search_by_cve(cve))

#         all_exploits = list({e['Path']: e for e in exploits_pv + exploits_cve}.values())

#         # Add exploits to the service data structure for exploit_runner
#         service['exploits'] = all_exploits

#         if all_exploits:
#             print(f"[+] Found {len(all_exploits)} exploits for port {port}:")
#             for e in all_exploits:
#                 print(f" - {e['Title']} (Path: {e['Path']})")
#         else:
#             print(f"[!] No exploits found for {product} {version} on port {port}")
    
#     return cve_results  # Return the modified results




import json
import logging
import re
from pathlib import Path

# load Exploit-DB JSON database once that is downloaded prior to running this script
EXPLOIT_DB_PATH = Path('exploitdb.json')

def load_exploitdb():
    if not EXPLOIT_DB_PATH.exists():
        logging.error(f"! ExploitDB JSON file not found: {EXPLOIT_DB_PATH}")
        return []
    with EXPLOIT_DB_PATH.open(encoding='utf-8') as f:
        data = json.load(f)
    return data.get("RESULTS_EXPLOIT", [])

# do it once when script starts
EXPLOIT_DB = load_exploitdb()


def search_by_product_version_in_memory(product, version):
    if not product:
        return []

    results = []
    
    # create multiple search patterns for better matching
    search_patterns = []
    
    # primarry pattern: product + version
    if version:
        search_patterns.append(f"{product} {version}".strip().lower())
        # also try without patch level for versions like "4.7p1"
        if 'p' in version:
            base_version = version.split('p')[0]
            search_patterns.append(f"{product} {base_version}".strip().lower())
    
    # fallback in case of failure: using just the product name
    search_patterns.append(product.lower())
    
    # for OpenSSH, also try "ssh" (will add later) as many exploits use general names
    if "openssh" in product.lower():
        search_patterns.append("ssh")
        if version:
            search_patterns.append(f"ssh {version}")

    for exploit in EXPLOIT_DB:
        title = exploit.get('Title', '').lower()
        
        # try each pattern
        for pattern in search_patterns:
            if pattern in title:
                results.append(exploit)
                break  # don't add the same exploit multiple times

    return results


def search_by_cves_in_memory(cve_list):
    if not cve_list:
        return []

    # build regular expression for the CVE (using the standard format): (CVE-2017-1234|CVE-2019-9999)
    cve_pattern = re.compile(r'(' + '|'.join(re.escape(cve) for cve in cve_list) + r')', re.IGNORECASE)
    results = []

    for exploit in EXPLOIT_DB:
        codes = exploit.get('Codes', '')  # Look in Codes field, not Title
        if cve_pattern.search(codes):
            results.append(exploit)
    return results


def exploit_services(cve_results): # driver function
    for service in cve_results:
        port = service.get('port')
        product = service.get('product', '')
        version = service.get('version', '')
        cve_list = service.get('cve_ids', [])  # Use cve_ids instead of cves

        # in-memory search using the loaded exploit database
        exploits_pv = search_by_product_version_in_memory(product, version)
        exploits_cve = search_by_cves_in_memory(cve_list)

        # Debug: Show what CVEs we're searching for
        if cve_list:
            print(f"DEBUG: Searching for CVEs: {cve_list}")
            print(f"DEBUG: Found {len(exploits_cve)} CVE-based exploits")

        # removing duplicates by path
        all_exploits = list({e['Path']: e for e in exploits_pv + exploits_cve}.values())
        service['exploits'] = all_exploits

        if all_exploits:
            print(f"-> Found {len(all_exploits)} exploits for {product} {version} on port {port}:")
            for e in all_exploits:
                print(f" - {e['Title']} (Path: {e['Path']})")
        else:
            print(f"! No exploits found for {product} {version} on port {port}")

    return cve_results
