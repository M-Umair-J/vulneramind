#!/usr/bin/env python3
"""
AI-Powered Vulnerability Assessment Report Generator
Generates comprehensive, professional vulnerability assessment reports with remediation strategies
"""

import json
import os
import sys
from datetime import datetime
from typing import List, Dict, Any, Optional
import re

# Add path to import local AI system
current_dir = os.path.dirname(os.path.abspath(__file__))
core_dir = os.path.join(current_dir, '..', '..', 'core')
sys.path.insert(0, core_dir)

try:
    from local_ai_system import local_ai
    AI_AVAILABLE = True
    print("ðŸ¤– Report AI system loaded successfully")
except ImportError as e:
    print(f"âš ï¸ Report AI not available: {e}")
    AI_AVAILABLE = False


class VulnerabilityReportGenerator:
    """
    Generates detailed vulnerability assessment reports using AI analysis
    """
    
    def __init__(self):
        self.report_template = {
            "executive_summary": "",
            "technical_findings": [],
            "risk_assessment": {},
            "remediation_plan": [],
            "appendices": {}
        }
    
    def generate_comprehensive_report(self, 
                                    target_host: str,
                                    scan_results: List[Dict[str, Any]],
                                    exploit_results: List[Dict[str, Any]] = None,
                                    ai_recommendations: List[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Generate a comprehensive vulnerability assessment report
        """
        
        # Analyze scan data
        vulnerability_analysis = self._analyze_vulnerabilities(scan_results)
        risk_metrics = self._calculate_risk_metrics(scan_results)
        
        # Generate report sections
        report = {
            "metadata": self._generate_metadata(target_host),
            "executive_summary": self._generate_executive_summary(target_host, vulnerability_analysis, risk_metrics),
            "methodology": self._generate_methodology_section(),
            "technical_findings": self._generate_technical_findings(scan_results, vulnerability_analysis),
            "risk_assessment": self._generate_risk_assessment(risk_metrics, vulnerability_analysis),
            "exploit_analysis": self._generate_exploit_analysis(exploit_results, ai_recommendations),
            "remediation_strategies": self._generate_remediation_strategies(scan_results, vulnerability_analysis),
            "compliance_impact": self._generate_compliance_section(vulnerability_analysis),
            "recommendations": self._generate_recommendations(vulnerability_analysis, risk_metrics),
            "appendices": self._generate_appendices(scan_results)
        }
        
        return report
    
    def _generate_metadata(self, target_host: str) -> Dict[str, Any]:
        """Generate report metadata"""
        return {
            "report_title": f"Vulnerability Assessment Report - {target_host}",
            "target_host": target_host,
            "scan_date": datetime.now().isoformat(),
            "report_version": "1.0",
            "generated_by": "VulneraMind AI Security Scanner",
            "classification": "CONFIDENTIAL",
            "scope": f"Network security assessment of host {target_host}"
        }
    
    def _analyze_vulnerabilities(self, scan_results: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Analyze vulnerabilities from scan results"""
        analysis = {
            "total_services": len(scan_results),
            "total_cves": 0,
            "severity_breakdown": {"CRITICAL": 0, "HIGH": 0, "MEDIUM": 0, "LOW": 0, "UNKNOWN": 0},
            "affected_services": [],
            "critical_findings": [],
            "service_analysis": {}
        }
        
        for service in scan_results:
            cves = service.get('cves', [])
            analysis["total_cves"] += len(cves)
            
            if cves:
                analysis["affected_services"].append({
                    "port": service.get('port'),
                    "service": service.get('service'),
                    "product": service.get('product', 'Unknown'),
                    "version": service.get('version', 'Unknown'),
                    "cve_count": len(cves),
                    "highest_score": max([cve.get('score', 0) for cve in cves], default=0)
                })
                
                # Analyze severity
                for cve in cves:
                    severity = cve.get('severity', 'UNKNOWN').upper()
                    analysis["severity_breakdown"][severity] = analysis["severity_breakdown"].get(severity, 0) + 1
                    
                    # Track critical findings
                    if severity in ['CRITICAL', 'HIGH'] and cve.get('score', 0) >= 7.0:
                        analysis["critical_findings"].append({
                            "service": f"{service.get('service')} (Port {service.get('port')})",
                            "cve": cve.get('id'),
                            "score": cve.get('score'),
                            "description": cve.get('description', '')[:200] + "..."
                        })
        
        return analysis
    
    def _calculate_risk_metrics(self, scan_results: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Calculate risk metrics and scoring"""
        total_score = 0
        cve_count = 0
        
        for service in scan_results:
            cves = service.get('cves', [])
            for cve in cves:
                score = cve.get('score', 0)
                total_score += score
                cve_count += 1
        
        avg_score = total_score / cve_count if cve_count > 0 else 0
        
        # Risk level determination
        if avg_score >= 7.0:
            risk_level = "CRITICAL"
            risk_color = "#dc2626"
        elif avg_score >= 5.0:
            risk_level = "HIGH"
            risk_color = "#ea580c"
        elif avg_score >= 3.0:
            risk_level = "MEDIUM"
            risk_color = "#d97706"
        else:
            risk_level = "LOW"
            risk_color = "#16a34a"
        
        return {
            "overall_risk_level": risk_level,
            "risk_color": risk_color,
            "average_cvss_score": round(avg_score, 2),
            "total_vulnerabilities": cve_count,
            "risk_score": min(100, int(avg_score * 10 + cve_count * 2))
        }
    
    def _generate_executive_summary(self, target_host: str, vulnerability_analysis: Dict, risk_metrics: Dict) -> str:
        """Generate AI-powered executive summary using Mistral"""
        
        if AI_AVAILABLE:
            try:
                print("ðŸ¤– Generating AI executive summary with Mistral...")
                
                data = {
                    'target_host': target_host,
                    'services': vulnerability_analysis.get('affected_services', []),
                    'total_cves': vulnerability_analysis.get('total_cves', 0),
                    'critical_cves': vulnerability_analysis['severity_breakdown'].get('CRITICAL', 0) + vulnerability_analysis['severity_breakdown'].get('HIGH', 0),
                    'risk_level': risk_metrics.get('overall_risk_level', 'Unknown')
                }
                
                ai_summary = local_ai.generate_report_section('executive_summary', data)
                
                if ai_summary and len(ai_summary) > 100:
                    print("âœ… AI executive summary generated")
                    return f"""## Executive Summary

**Target Assessment:** {target_host}  
**Assessment Date:** {datetime.now().strftime('%B %d, %Y')}  
**Overall Risk Level:** {risk_metrics['overall_risk_level']}

{ai_summary}

**Key Metrics:**
- **Total Vulnerabilities:** {vulnerability_analysis.get('total_cves', 0)}
- **Critical/High Risk:** {vulnerability_analysis['severity_breakdown'].get('CRITICAL', 0) + vulnerability_analysis['severity_breakdown'].get('HIGH', 0)}
- **Risk Score:** {risk_metrics.get('risk_score', 0)}/100
- **Services Affected:** {len(vulnerability_analysis.get('affected_services', []))}

---
*This executive summary was generated using AI analysis of vulnerability data.*
"""
                    
            except Exception as e:
                print(f"âŒ AI summary generation failed: {e}")
        
        # Fallback to template if AI fails
        print("âš ï¸ Using fallback template for executive summary")
        critical_count = vulnerability_analysis["severity_breakdown"]["CRITICAL"]
        high_count = vulnerability_analysis["severity_breakdown"]["HIGH"]
        total_services = vulnerability_analysis["total_services"]
        total_cves = vulnerability_analysis["total_cves"]
        
        return f"""## Executive Summary

**Target Assessment:** {target_host}  
**Assessment Date:** {datetime.now().strftime('%B %d, %Y')}  
**Overall Risk Level:** {risk_metrics['overall_risk_level']}

### Key Findings

This comprehensive security assessment of **{target_host}** has identified **{total_cves} vulnerabilities** across **{total_services} network services**. The assessment reveals an overall risk level of **{risk_metrics['overall_risk_level']}** with an average CVSS score of **{risk_metrics['average_cvss_score']}**.

### Critical Security Concerns

- **{critical_count} CRITICAL** severity vulnerabilities requiring immediate attention
- **{high_count} HIGH** severity vulnerabilities requiring urgent remediation
- **{len(vulnerability_analysis['affected_services'])} services** are directly affected by known security vulnerabilities
- **Risk Score: {risk_metrics['risk_score']}/100**

### Business Impact

The identified vulnerabilities present significant security risks that could result in:
- **Data Breach:** Unauthorized access to sensitive information
- **System Compromise:** Complete system takeover by malicious actors
- **Service Disruption:** Potential denial of service attacks
- **Compliance Violations:** Failure to meet security standards and regulations

### Immediate Actions Required

1. **Priority 1:** Address all CRITICAL and HIGH severity vulnerabilities within 24-48 hours
2. **Priority 2:** Implement network segmentation and access controls
3. **Priority 3:** Deploy comprehensive monitoring and intrusion detection systems
4. **Priority 4:** Establish regular vulnerability management processes

This report provides detailed technical findings, risk assessments, and comprehensive remediation strategies to address all identified security concerns.
"""
    
    def _generate_methodology_section(self) -> str:
        """Generate methodology section"""
        return """
## Assessment Methodology

### Scanning Approach
This vulnerability assessment was conducted using the VulneraMind AI Security Scanner, employing industry-standard methodologies and tools.

### Assessment Phases
1. **Host Discovery:** Network reconnaissance to identify live hosts
2. **Port Scanning:** Comprehensive port enumeration using advanced scanning techniques
3. **Service Detection:** Detailed service fingerprinting and version identification
4. **Vulnerability Mapping:** CVE database correlation with NVD (National Vulnerability Database)
5. **Exploit Analysis:** Automated exploit identification using ExploitDB
6. **AI-Powered Analysis:** Machine learning-based risk assessment and remediation planning

### Tools and Databases
- **CVE Database:** 88,820+ vulnerabilities from NIST NVD
- **Exploit Database:** 50,000+ verified exploits from Offensive Security
- **AI Engine:** Advanced machine learning models for threat analysis
- **Compliance Frameworks:** NIST, OWASP, CIS Controls alignment

### Assessment Scope
- Network services and applications
- Known vulnerability identification
- Exploit availability assessment
- Risk quantification and prioritization
        """
    
    def _generate_technical_findings(self, scan_results: List[Dict], vulnerability_analysis: Dict) -> str:
        """Generate detailed technical findings"""
        
        findings = "## Technical Findings\n\n"
        
        for i, service in enumerate(scan_results, 1):
            port = service.get('port')
            service_name = service.get('service')
            product = service.get('product', 'Unknown')
            version = service.get('version', 'Unknown')
            cves = service.get('cves', [])
            
            findings += f"### Finding #{i}: Port {port}/{service.get('protocol', 'tcp')} - {service_name}\n\n"
            findings += f"**Service Details:**\n"
            findings += f"- **Product:** {product}\n"
            findings += f"- **Version:** {version}\n"
            findings += f"- **Detection Confidence:** {service.get('confidence', 'Unknown')}\n\n"
            
            if cves:
                findings += f"**Security Vulnerabilities ({len(cves)} found):**\n\n"
                
                # Sort CVEs by score (highest first)
                sorted_cves = sorted(cves, key=lambda x: x.get('score', 0), reverse=True)
                
                # Show ALL CVEs, not just top 5
                for j, cve in enumerate(sorted_cves, 1):
                    severity = cve.get('severity', 'UNKNOWN')
                    score = cve.get('score', 0)
                    
                    findings += f"**{j}. {cve.get('id')} ({severity} - CVSS {score})**\n"
                    # Show FULL description, not truncated
                    findings += f"   - {cve.get('description', 'No description available')}\n\n"
            else:
                findings += "**Security Status:** No known vulnerabilities identified\n\n"
            
            findings += "---\n\n"
        
        return findings
    
    def _generate_risk_assessment(self, risk_metrics: Dict, vulnerability_analysis: Dict) -> str:
        """Generate risk assessment section"""
        
        assessment = f"""
## Risk Assessment

### Overall Risk Profile
- **Risk Level:** {risk_metrics['overall_risk_level']}
- **Risk Score:** {risk_metrics['risk_score']}/100
- **Average CVSS Score:** {risk_metrics['average_cvss_score']}

### Vulnerability Distribution
- **CRITICAL:** {vulnerability_analysis['severity_breakdown']['CRITICAL']} vulnerabilities
- **HIGH:** {vulnerability_analysis['severity_breakdown']['HIGH']} vulnerabilities  
- **MEDIUM:** {vulnerability_analysis['severity_breakdown']['MEDIUM']} vulnerabilities
- **LOW:** {vulnerability_analysis['severity_breakdown']['LOW']} vulnerabilities

### Risk Factors

#### High-Risk Services
"""
        
        # Add high-risk services
        high_risk_services = [s for s in vulnerability_analysis['affected_services'] if s['highest_score'] >= 7.0]
        
        if high_risk_services:
            for service in high_risk_services:
                assessment += f"- **Port {service['port']} ({service['service']}):** {service['cve_count']} vulnerabilities, highest CVSS {service['highest_score']}\n"
        else:
            assessment += "- No services identified with CVSS scores â‰¥ 7.0\n"
        
        assessment += f"""

### Attack Surface Analysis
- **Total Exposed Services:** {vulnerability_analysis['total_services']}
- **Vulnerable Services:** {len(vulnerability_analysis['affected_services'])}
- **Attack Vector Availability:** {'High' if len(vulnerability_analysis['critical_findings']) > 0 else 'Medium'}

### Likelihood vs Impact Matrix
Based on the identified vulnerabilities, the likelihood of successful exploitation is **{risk_metrics['overall_risk_level']}**, with potential business impact ranging from service disruption to complete system compromise.
        """
        
        return assessment
    
    def _generate_exploit_analysis(self, exploit_results: List[Dict] = None, ai_recommendations: List[Dict] = None) -> str:
        """Generate exploit analysis section"""
        
        if not exploit_results:
            return """
## Exploit Analysis

### Exploit Availability
No exploit analysis was performed during this assessment. For a comprehensive security evaluation, it is recommended to conduct exploit verification testing in a controlled environment.

### Recommendations
- Perform penetration testing to validate vulnerability exploitability
- Implement proof-of-concept testing for critical vulnerabilities
- Establish responsible disclosure processes for identified security issues
            """
        
        analysis = "## Exploit Analysis\n\n"
        
        total_exploits = sum(len(service.get('exploits', [])) for service in exploit_results)
        
        analysis += f"### Exploit Landscape\n"
        analysis += f"- **Total Exploits Available:** {total_exploits}\n"
        analysis += f"- **Affected Services:** {len([s for s in exploit_results if s.get('exploits')])}\n\n"
        
        if ai_recommendations:
            analysis += f"### AI-Generated Metasploit Modules\n"
            analysis += f"The AI engine has identified **{len(ai_recommendations)}** specific Metasploit modules that could be used to exploit the identified vulnerabilities.\n\n"
            
            for i, rec in enumerate(ai_recommendations[:3], 1):  # Show top 3
                if 'ai_suggestion' in rec and not rec['ai_suggestion'].get('error'):
                    analysis += f"**{i}. {rec['exploit'].get('Title', 'Unknown Exploit')}**\n"
                    analysis += f"   - Module: `{rec['ai_suggestion'].get('exploit_module', 'N/A')}`\n"
                    analysis += f"   - Payload: `{rec['ai_suggestion'].get('payload', 'N/A')}`\n\n"
        
        analysis += """
### Security Implications
The availability of public exploits significantly increases the risk of successful attacks. These exploits can be leveraged by both legitimate security testers and malicious actors.

### Mitigation Priority
Services with available exploits should be prioritized for immediate patching and additional security controls.
        """
        
        return analysis
    
    def _generate_remediation_strategies(self, scan_results: List[Dict], vulnerability_analysis: Dict) -> str:
        """Generate AI-powered remediation strategies using Mistral"""
        
        if AI_AVAILABLE:
            try:
                print("ðŸ¤– Generating AI remediation strategies with Mistral...")
                
                data = {
                    'services': vulnerability_analysis.get('affected_services', []),
                    'total_cves': vulnerability_analysis.get('total_cves', 0),
                    'critical_cves': vulnerability_analysis['severity_breakdown'].get('CRITICAL', 0),
                    'risk_level': 'HIGH' if vulnerability_analysis['severity_breakdown'].get('CRITICAL', 0) > 0 else 'MEDIUM'
                }
                
                ai_strategies = local_ai.generate_report_section('remediation_strategy', data)
                
                if ai_strategies and len(ai_strategies) > 100:
                    print("âœ… AI remediation strategies generated")
                    return f"""## Remediation Strategies

{ai_strategies}

### Critical Findings Requiring Immediate Action
"""
                    
            except Exception as e:
                print(f"âŒ AI remediation generation failed: {e}")
        
        # Fallback to template
        print("âš ï¸ Using fallback template for remediation strategies")
        
        strategies = """## Remediation Strategies

### Immediate Actions (0-24 hours)

#### Critical Vulnerability Remediation
"""
        
        for finding in vulnerability_analysis['critical_findings']:
            strategies += f"- **{finding['service']}:** Patch {finding['cve']} (CVSS {finding['score']})\n"
        
        strategies += """

#### Emergency Response Measures
1. **Network Isolation:** Isolate affected systems from critical network segments
2. **Access Control:** Implement strict firewall rules and access restrictions
3. **Monitoring:** Deploy enhanced logging and monitoring for affected services
4. **Backup Verification:** Ensure backup systems are secure and functional

### Short-term Actions (1-7 days)

#### Vulnerability Patching
1. **Patch Management:** Deploy security updates for all identified vulnerabilities
2. **Service Hardening:** Configure services with security best practices
3. **Access Controls:** Implement principle of least privilege
4. **Network Segmentation:** Isolate vulnerable services where possible

#### Configuration Improvements
"""
        
        for service in vulnerability_analysis['affected_services']:
            strategies += f"- **{service['service']} (Port {service['port']}):** Update to latest secure version, review configuration\n"
        
        strategies += """

### Long-term Actions (1-4 weeks)

#### Infrastructure Improvements
1. **Security Architecture:** Implement defense-in-depth strategies
2. **Continuous Monitoring:** Deploy SIEM and intrusion detection systems
3. **Vulnerability Management:** Establish regular vulnerability scanning schedules
4. **Incident Response:** Develop and test incident response procedures

#### Process Enhancements
1. **Security Policies:** Update security policies and procedures
2. **Staff Training:** Conduct security awareness training
3. **Regular Assessments:** Schedule quarterly security assessments
4. **Compliance Alignment:** Ensure alignment with security frameworks

### Ongoing Maintenance

#### Vulnerability Management Program
1. **Regular Scanning:** Weekly vulnerability scans
2. **Patch Management:** Automated patch deployment where possible
3. **Risk Assessment:** Monthly risk assessment reviews
4. **Security Metrics:** Track and report security improvement metrics
"""
        
        return strategies
    
    def _generate_compliance_section(self, vulnerability_analysis: Dict) -> str:
        """Generate compliance impact section"""
        
        critical_count = vulnerability_analysis['severity_breakdown']['CRITICAL']
        high_count = vulnerability_analysis['severity_breakdown']['HIGH']
        
        return f"""
## Compliance Impact

### Regulatory Considerations

#### NIST Cybersecurity Framework
- **Identify:** Vulnerabilities have been identified and cataloged
- **Protect:** Additional protective measures required for {critical_count + high_count} high-risk vulnerabilities  
- **Detect:** Enhanced monitoring recommended for vulnerable services
- **Respond:** Incident response procedures should address identified risks
- **Recover:** Recovery plans should account for potential exploitation scenarios

#### CIS Critical Security Controls
- **Control 3 (Data Protection):** Vulnerable services may expose sensitive data
- **Control 7 (Email and Web Browser Protections):** Web services require additional hardening
- **Control 11 (Data Recovery):** Backup systems must be protected from identified threats
- **Control 16 (Application Software Security):** Application vulnerabilities require immediate attention

#### Industry Standards (ISO 27001, SOC 2)
- **Risk Management:** Current vulnerability landscape presents compliance risks
- **Access Control:** Additional controls required for vulnerable services
- **Security Monitoring:** Enhanced monitoring required to meet compliance requirements
- **Incident Management:** Procedures must address potential exploitation scenarios

### Compliance Recommendations
1. Document all remediation activities for audit purposes
2. Implement continuous compliance monitoring
3. Regular compliance assessment reviews
4. Maintain detailed security control implementation records
        """
    
    def _generate_recommendations(self, vulnerability_analysis: Dict, risk_metrics: Dict) -> str:
        """Generate strategic recommendations"""
        
        return f"""
## Strategic Recommendations

### Executive Priorities

#### 1. Immediate Risk Mitigation
- **Timeframe:** 24-48 hours
- **Investment:** High priority budget allocation for critical patches
- **Ownership:** IT Security Team with executive oversight

#### 2. Security Program Enhancement  
- **Timeframe:** 30-90 days
- **Investment:** Moderate investment in security tools and training
- **Ownership:** CISO with cross-functional team support

#### 3. Long-term Security Posture
- **Timeframe:** 6-12 months  
- **Investment:** Strategic investment in security architecture
- **Ownership:** Executive leadership with board oversight

### Technical Recommendations

#### Security Architecture
1. **Zero Trust Implementation:** Move towards zero trust security model
2. **Micro-segmentation:** Implement network micro-segmentation
3. **Endpoint Protection:** Deploy advanced endpoint detection and response
4. **Security Orchestration:** Implement SOAR capabilities for automated response

#### Operational Improvements
1. **DevSecOps Integration:** Integrate security into development lifecycle
2. **Threat Intelligence:** Implement threat intelligence feeds
3. **Security Metrics:** Develop comprehensive security metrics dashboard
4. **Regular Testing:** Establish regular penetration testing program

### Budget Considerations
- **Immediate Costs:** ${'{:,}'.format(vulnerability_analysis['total_cves'] * 500)} (estimated patching costs)
- **Short-term Investment:** ${'{:,}'.format(50000)} (security tool improvements)
- **Annual Program Cost:** ${'{:,}'.format(150000)} (ongoing security program)

### Success Metrics
- Reduce critical vulnerabilities to zero within 30 days
- Achieve 95% patch compliance within 60 days
- Implement continuous monitoring within 90 days
- Establish mature vulnerability management program within 180 days
        """
    
    def _generate_appendices(self, scan_results: List[Dict]) -> Dict[str, Any]:
        """Generate appendices with detailed data"""
        
        return {
            "vulnerability_details": {
                "description": "Complete vulnerability listing with technical details",
                "data": scan_results
            },
            "cvss_scoring": {
                "description": "CVSS v3.1 scoring methodology and interpretation guide",
                "methodology": "Common Vulnerability Scoring System version 3.1 provides standardized vulnerability severity ratings"
            },
            "references": {
                "NIST_NVD": "https://nvd.nist.gov/",
                "ExploitDB": "https://www.exploit-db.com/",
                "CVSS_Calculator": "https://www.first.org/cvss/calculator/3.1",
                "OWASP_Top10": "https://owasp.org/Top10/"
            }
        }
    
    def format_as_markdown(self, report: Dict[str, Any]) -> str:
        """Convert report to markdown format"""
        
        markdown = f"""# {report['metadata']['report_title']}

**Generated:** {datetime.now().strftime('%B %d, %Y at %I:%M %p')}
**Classification:** {report['metadata']['classification']}
**Version:** {report['metadata']['report_version']}

---

{report['executive_summary']}

---

{report['methodology']}

---

{report['technical_findings']}

---

{report['risk_assessment']}

---

{report['exploit_analysis']}

---

{report['remediation_strategies']}

---

{report['compliance_impact']}

---

{report['recommendations']}

---

## Report Metadata

- **Target Host:** {report['metadata']['target_host']}
- **Scan Date:** {report['metadata']['scan_date']}
- **Generated By:** {report['metadata']['generated_by']}
- **Report Scope:** {report['metadata']['scope']}

---

*This report was generated by VulneraMind AI Security Scanner. For questions or additional analysis, please contact your security team.*
        """
        
        return markdown

# Convenience function for easy import
def generate_vulnerability_report(target_host: str, 
                                scan_results: List[Dict[str, Any]], 
                                exploit_results: List[Dict[str, Any]] = None,
                                ai_recommendations: List[Dict[str, Any]] = None) -> Dict[str, Any]:
    """
    Generate a comprehensive vulnerability assessment report
    
    Args:
        target_host: The target host that was scanned
        scan_results: Results from vulnerability scanning
        exploit_results: Results from exploit analysis (optional)
        ai_recommendations: AI-generated recommendations (optional)
    
    Returns:
        Dictionary containing the complete report
    """
    generator = VulnerabilityReportGenerator()
    return generator.generate_comprehensive_report(
        target_host, scan_results, exploit_results, ai_recommendations
    )
